local assdraw = require 'mp.assdraw'
local msg = require 'mp.msg'
local opt = require 'mp.options'
local utils = require 'mp.utils'

-- Windows: C:\Users\USER\AppData\Roaming\mpv\script-opts\tethys.conf
-- Linux: ~/config/mpv/script-opts/tethys.conf
local tethys = {
    -- Config
    showPictureInPictureButton = true,
    showSpeedButton = true,
    showShortcutTooltip = true, -- Show name and shortcut of buttons on hover
    showChapterTooltip = true, -- Show chapter above timestamp in seekbar tooltip
    skipBy = 5, -- skipback/skipfrwd amount in seconds
    skipByMore = 30, -- RightClick skipback/skipfrwd amount in seconds
    skipMode = "exact", -- "exact" (mordenx default) or "relative+keyframes" (mpv default)
    pipGeometry = "33%+-10+-10", -- PictureInPicture 33% screen width, 10px from bottom right
    pipAllWorkspaces = true, -- PictureInPicture will show video on all virtual desktops

    -- Sizes
    thumbnailSize = 256, -- 16:9 = 256x144
    seekbarHeight = 20,
    controlsHeight = 64,
    smallButtonSize = 42, -- controlsHeight * 2/3
    trackButtonSize = 36, -- controlsHeight / 2
    buttonTooltipSize = 20,
    windowBarHeight = 44,
    windowButtonSize = 44,
    windowTitleSize = 24,
    cacheTextSize = 20,
    timecodeSize = 27,
    seekbarTimestampSize = 30,
    seekbarTimestampOutline = 1,
    chapterTickSize = 6,
    windowTitleOutline = 1,

    -- Misc
    osdSymbolFont = "mpv-osd-symbols", -- Seems to be hardcoded and unchangeable

    -- Colors (uses GGBBRR for some reason)
    -- Alpha ranges 0 (opaque) .. 255 (transparent)
    textColor = "FFFFFF",
    buttonColor = "CCCCCC",
    buttonHoveredColor = "FFFFFF",
    buttonHoveredRectColor = "000000",
    buttonHoveredRectAlpha = 255, -- Easily debug button geometry by setting to 80
    tooltipColor = "CCCCCC",
    windowBarColor = "000000",
    windowBarAlpha = 255, -- (80 is mpv default) (255 morden default)
    windowButtonColor = "CCCCCC",
    closeButtonHoveredColor = "1111DD", -- #DD1111
    seekbarHandleColor = "FFFFFF",
    seekbarFgColor = "483DD7", -- #d73d48
    seekbarBgColor = "929292",
    seekbarCacheColor = "000000",
    seekbarCacheAlpha = 128,
    chapterTickColor = "CCCCCC",
}
read_options(tethys, "tethys")

local function parseColor(color)
    if string.find(color, "#") then
        local colorU = string.upper(color)
        local r = string.sub(colorU, 2, 3)
        local g = string.sub(colorU, 4, 5)
        local b = string.sub(colorU, 6, 7)
        return b..g..r
    else
        return color
    end
end
local function parseConfig(configTable)
    for k,v in pairs(configTable) do
        if string.find(k, "Color") then
            configTable[k] = parseColor(v)
        end
    end
end

parseConfig(tethys)

tethys.bottomBarHeight = tethys.seekbarHeight + tethys.controlsHeight
tethys.buttonW = tethys.controlsHeight
tethys.buttonH = tethys.controlsHeight
tethys.smallButtonSize = math.min(tethys.controlsHeight, tethys.smallButtonSize)
tethys.trackButtonSize = math.min(tethys.controlsHeight, tethys.trackButtonSize)
tethys.windowButtonSize = math.min(tethys.windowBarHeight, tethys.windowButtonSize)
tethys.windowControlsRect = {
    w = tethys.windowButtonSize * 3,
    h = tethys.windowBarHeight,
}

tethys.trackTextScale = 105

-- [1] Foreground, [2] Karaoki Foreground, [3] Border, [4] Shadow
-- https://aegi.vmoe.info/docs/3.0/ASS_Tags/#index22h3
tethys.windowBarAlphaTable = {[1] = tethys.windowBarAlpha, [2] = 255, [3] = 255, [4] = 255}
tethys.seekbarCacheAlphaTable = {[1] = tethys.seekbarCacheAlpha, [2] = 255, [3] = 255, [4] = 255}
tethys.tooltipAlphaTable =  {[1] = 0, [2] = 255, [3] = 88, [4] = 255} -- Opache Text, 65% opacity outlines

tethys.showButtonHoveredRect = tethys.buttonHoveredRectAlpha < 255 -- Note: 255=transparent

tethys.isPictureInPicture = false
tethys.pipWasFullscreen = false
tethys.pipWasMaximized = false
tethys.pipWasOnTop = false
tethys.pipHadBorders = false


-- https://github.com/libass/libass/wiki/ASSv5-Override-Tags#color-and-alpha---c-o
function genColorStyle(color)
    return "{\\c&H"..color.."&}" -- Not sure why &H...& is used in santa_hat_lines
    -- return "{\\c("..color..")}" -- Works
    -- return "{\\c(#"..color..")}" -- Only works for paths, and breaks other stuff.
end

---- mpv's stats.lua has some ASS formatting
-- https://aegi.vmoe.info/docs/3.0/ASS_Tags/
-- https://github.com/libass/libass/wiki/ASSv5-Override-Tags
-- https://github.com/mpv-player/mpv/blob/master/player/lua/stats.lua#L62
-- https://github.com/mpv-player/mpv/blob/master/player/lua/stats.lua#L176
-- "{\\r}{\\an7}{\\fs%d}{\\fn%s}{\\bord%f}{\\3c&H%s&}{\\1c&H%s&}{\\alpha&H%s&}{\\xshad%f}{\\yshad%f}{\\4c&H%s&}"
-- {\\bord%f} = border size
-- {\\3c&H%s&} = border color
-- {\\1c&H%s&} = font color
-- {\\alpha&H%s&} = alpha
-- {\\xshad%f}{\\yshad%f} = shadow x,y offset
-- {\\4c&H%s&} = shadow color
-- {\\b(400)} = font weight, 400=normal, 700=bold
---- \\q2 in windowTitle is unknown
---- Not sure why \1c is rect fill color. Here's docs for \3c:
-- https://github.com/libass/libass/wiki/Libass'-ASS-Extensions#borderstyle4
-- "{\\1c&H"..color.."}"
local tethysStyle = {
    button = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)\\fn(%s)}"):format(tethys.buttonColor, tethys.buttonH, tethys.osdSymbolFont),
    buttonHovered = genColorStyle(tethys.buttonHoveredColor),
    buttonHoveredRect = ("{\\rDefault\\blur0\\bord0\\1c&H%s\\1a&H%X&}"):format(tethys.buttonHoveredRectColor, tethys.buttonHoveredRectAlpha),
    smallButton = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)\\fn(%s)}"):format(tethys.buttonColor, tethys.smallButtonSize, tethys.osdSymbolFont),
    trackButton = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)\\fn(%s)}"):format(tethys.buttonColor, tethys.trackButtonSize, tethys.osdSymbolFont),
    trackText = ("{\\fscx%s\\fscy%s\\fn(%s)}"):format(tethys.trackTextScale, tethys.trackTextScale, mp.get_property("options/osd-font")),
    windowBar = ("{\\1c&H%s}"):format(tethys.windowBarColor),
    windowButton = ("{\\blur0\\bord(%d)\\1c&H%s\\3c&H000000\\fs(%d)\\fn(%s)}"):format(tethys.windowTitleOutline, tethys.windowButtonColor, tethys.windowButtonSize, tethys.osdSymbolFont),
    closeButtonHovered = genColorStyle(tethys.closeButtonHoveredColor),
    windowTitle = ("{\\blur0\\bord(%d)\\1c&H%s\\3c&H000000\\fs(%d)}"):format(tethys.windowTitleOutline, tethys.textColor, tethys.windowTitleSize),
    buttonTooltip = ("{\\blur0\\bord(1)\\1c&H%s\\3c&H000000\\fs(%d)}"):format(tethys.tooltipColor, tethys.buttonTooltipSize),
    buttonKeybindFormat = ("{\\bord(3)\\b(700)} %s {\\bord(1)\\b(400)}"), -- Spaces around the key to accound for thick outlines
    timecode = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)}"):format(tethys.textColor, tethys.timecodeSize),
    cacheText = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)}"):format(tethys.textColor, tethys.cacheTextSize, tethys.osdSymbolFont),
    seekbar = ("{\\blur0\\bord0\\1c&H%s\\3c&HFFFFFF\\fs(%d)}"):format(tethys.seekbarFgColor, tethys.seekbarHeight),
    seekbarTimestamp = ("{\\blur0\\bord(%d)\\1c&H%s\\3c&H000000\\fs(%d)}"):format(tethys.seekbarTimestampOutline, tethys.textColor, tethys.seekbarTimestampSize),
    text = genColorStyle(tethys.textColor),
    seekbarHandle = genColorStyle(tethys.seekbarHandleColor),
    seekbarFg = genColorStyle(tethys.seekbarFgColor),
    seekbarBg = genColorStyle(tethys.seekbarBgColor),
    seekbarCache = genColorStyle(tethys.seekbarCacheColor),
    chapterTick = genColorStyle(tethys.chapterTickColor),
}

---- Icons
-- 44x44
local tethysIcon_play = "{\\p1}m 0 0   m 44 44   m 37.236218 17.599999   b 41.584084 20.610064 41.584084 21.923269 37.236218 24.933333   b 22.516553 35.123867 9.369549 44 6.436216 44   b 3.502883 44 3.502883 39.6 3.502883 21.266665   b 3.502883 4.4 3.502883 0 6.436216 0   b 9.369549 0 22.516553 7.409462 37.236218 17.599999{\\p0}"
local tethysIcon_pause = "{\\p1}m 0 0   m 44 44   m 17.5 40.2064   b 17.5 45.263808 4.5 45.263808 4.5 40.2107   l 4.5 3.793057   b 4.5 -1.264352 17.5 -1.264352 17.5 3.793057   m 39.5 40.2064   b 39.5 45.263808 26.5 45.263808 26.5 40.2107   l 26.5 3.793057   b 26.5 -1.264352 39.5 -1.264352 39.5 3.793057{\\p0}"
local mpvOsdIcon_close = "{\\p1}m 0 0   m 44 44   m 34 34   l 30.571428 34   l 22 25.535715   l 13.535714 34   l 10 34   l 10 30.571428   l 18.464286 22   l 10 13.535714   l 10 10   l 13.535714 10   l 22 18.464286   l 30.571428 10   l 34 10   l 34 13.535714   l 25.535715 22   l 34 30.464285{\\p0}"
local mpvOsdIcon_maximize = "{\\p1}m 0 0   m 44 44   m 34 33   l 10 33   l 10 11   l 34 11   m 32 31   l 32 15   l 12 15   l 12 31{\\p0}"
local mpvOsdIcon_minimize = "{\\p1}m 0 0   m 44 44   m 34 25   l 10 25   l 10 19   l 34 19{\\p0}"
local mpvOsdIcon_restore = "{\\p1}m 0 0   m 44 44   m 34 25   l 27.999999 25   l 27.999999 33   l 10 33   l 10 18.999999   l 16 18.999999   l 16 11   l 34 11   m 32 23.000001   l 32 15   l 18 15   l 18 18.999999   l 27.999999 18.999999   l 27.999999 23.000001   m 26 31   l 26 23.000001   l 12 23.000001   l 12 31{\\p0}"
-- 32x28
local mpvOsdIcon_fs_enter = "{\\p1}m 0 0   m 32 28   m 0 23.454546   l 0 4.545454   b 0 3.454545 1.090909 2.363636 2.181818 2.363636   l 29.818182 2.363636   b 30.90909 2.363636 32 3.454545 32 4.545454   l 32 23.454546   b 32 24.545456 30.90909 25.636364 29.818182 25.636364   l 2.181818 25.636364   b 1.090909 25.636364 0 24.545456 0 23.454546   m 2.181818 23.454546   l 29.818182 23.454546   l 29.818182 4.545454   l 2.181818 4.545454   m 21.090909 6.727272   l 27.636363 6.727272   l 27.636363 13.272728   m 22.036363 11.09091   l 22.036363 16.872726   l 9.963636 16.872726   l 9.963636 11.09091   m 10.909091 21.272728   l 4.363636 21.272728   l 4.363636 14.727272{\\p0}"
local mpvOsdIcon_fs_exit = "{\\p1}m 0 0   m 32 28   m 0 23.454546   l 0 4.545454   b 0 3.454545 1.090909 2.363636 2.181818 2.363636   l 29.818182 2.363636   b 30.909091 2.363636 32 3.454545 32 4.545454   l 32 23.454546   b 32 24.545454 30.909091 25.636364 29.818182 25.636364   l 2.181818 25.636364   b 1.090909 25.636364 0 24.545454 0 23.454546   m 2.181818 23.454546   l 29.818182 23.454546   l 29.818182 4.545454   l 2.181818 4.545454   m 8.254546 14.000001   l 4.363636 18   l 4.363636 10   m 27.636364 18   l 23.745455 14.000001   l 27.636364 10   m 21.636364 10.181818   l 21.636364 17.781818   l 10.363636 17.781818   l 10.363636 10.181818{\\p0}"
-- 28x28
local tethysIcon_ch_prev = "{\\p1}m 0 0   m 28 28   m 15.555834 12.5   b 14.073607 13.526159 14.073607 13.973842 15.555834 15.000001   b 20.573903 18.474048 25.055836 21.5 26.055836 21.5   b 27.055835 21.5 27.055835 20.000001 27.055835 13.75   b 27.055835 8.000001 27.055835 6.5 26.055836 6.5   b 25.055836 6.5 20.573903 9.025952 15.555834 12.5   m 2.055835 12.5   b 0.573608 13.526159 0.573608 13.973842 2.055835 15.000001   b 7.073904 18.474048 11.555837 21.5 12.555836 21.5   b 13.555836 21.5 13.555836 20.000001 13.555836 13.75   b 13.555836 8.000001 13.555836 6.5 12.555836 6.5   b 11.555837 6.5 7.073904 9.025952 2.055835 12.5{\\p0}"
local tethysIcon_ch_next = "{\\p1}m 0 0   m 28 28   m 12.444166 12.5   b 13.926393 13.526159 13.926393 13.973842 12.444166 15.000001   b 7.426097 18.474048 2.944164 21.5 1.944165 21.5   b 0.944165 21.5 0.944165 20.000001 0.944165 13.75   b 0.944165 8.000001 0.944165 6.5 1.944165 6.5   b 2.944164 6.5 7.426097 9.025952 12.444166 12.5   m 25.944165 12.5   b 27.426392 13.526159 27.426392 13.973842 25.944165 15.000001   b 20.926096 18.474048 16.444163 21.5 15.444164 21.5   b 14.444164 21.5 14.444164 20.000001 14.444164 13.75   b 14.444164 8.000001 14.444164 6.5 15.444164 6.5   b 16.444163 6.5 20.926096 9.025952 25.944165 12.5{\\p0}"
local tethysIcon_pip_enter = "{\\p1}m 0 0   m 28 28   m 14 16   l 22 16   l 22 21   l 14 21   m 2 5   b 2 5 2 22 2 23   b 2 24 3 25 4 25   b 5 25 24 25 24 25   b 25 25 26 24 26 23   l 26 5   b 26 4 25 3 24 3   l 4 3   b 3 3 2 4 2 5   m 4 5   l 24 5   l 24 23   l 4 23{\\p0}"
local tethysIcon_pip_exit = "{\\p1}m 0 0   m 28 28   m 14 3   l 14 5   l 24 5   l 24 23   l 4 23   l 4 16   l 2 16   l 2 23   b 2 24 3 25 4 25   l 24 25   b 25 25 26 24 26 23   l 26 5   b 26 4 25 3 24 3   m 2 3   l 2 12   l 4 12   l 4 7   l 18 20   l 20 18   l 6 5   l 11 5   l 11 3{\\p0}"
local tethysIcon_pl_prev = "{\\p1}m 0 0   m 28 28   m 10.133332 11.8   b 7.959399 13.305034 7.959399 13.961635 10.133332 15.466668   b 17.493166 20.561937 24.066668 25 25.533334 25   b 27 25 27 22.800002 27 13.633333   b 27 5.200001 27 3 25.533334 3   b 24.066668 3 17.493166 6.70473 10.133332 11.8   m 1 23.103196   b 1 25.631901 7.574631 25.631901 7.574631 23.105396   l 7.574631 4.896528   b 7.574631 2.367824 1 2.367824 1 4.896528{\\p0}"
local tethysIcon_pl_next = "{\\p1}m 0 0   m 28 28   m 17.866668 11.8   b 20.040601 13.305034 20.040601 13.961635 17.866668 15.466668   b 10.506834 20.561937 3.933332 25 2.466666 25   b 1 25 1 22.800002 1 13.633333   b 1 5.200001 1 3 2.466666 3   b 3.933332 3 10.506834 6.70473 17.866668 11.8   m 27 23.103196   b 27 25.631901 20.425369 25.631901 20.425369 23.105396   l 20.425369 4.896528   b 20.425369 2.367824 27 2.367824 27 4.896528{\\p0}"
local tethysIcon_skipback = "{\\p1}m 0 0   m 28 28   m 2.511898 -0   l 2.511898 9.57764   l 12.089539 9.57764   l 12.089539 6.385093   l 8.163287 6.385093   b 11.540598 3.999689 16.093522 3.879191 19.632345 6.243757   b 23.661324 8.935835 25.219633 14.07368 23.365296 18.550442   b 21.510961 23.027205 16.775533 25.558703 12.023026 24.613371   b 7.27052 23.668038 3.864989 19.515531 3.864989 14.669918   l 0.672442 14.669918   b 0.672442 21.018992 5.172403 26.50492 11.399482 27.743563   b 17.626561 28.982206 23.884976 25.638369 26.314661 19.772589   b 28.744346 13.906809 26.684352 7.114815 21.40529 3.587458   b 18.765759 1.82378 15.680838 1.117147 12.694376 1.411288   b 10.187051 1.658238 7.750413 2.61433 5.704444 4.242179   l 5.704444 -0{\\p0}"
local tethysIcon_skipfrwd = "{\\p1}m 0 0   m 28 28   m 25.488102 -0   l 25.488102 9.57764   l 15.910461 9.57764   l 15.910461 6.385093   l 19.836712 6.385093   b 16.459402 3.999689 11.906478 3.879191 8.367655 6.243757   b 4.338676 8.935835 2.780367 14.07368 4.634704 18.550442   b 6.489039 23.027205 11.224467 25.558703 15.976974 24.613371   b 20.729479 23.668038 24.135011 19.515531 24.135011 14.669918   l 27.327558 14.669918   b 27.327558 21.018992 22.827597 26.50492 16.600518 27.743563   b 10.373439 28.982206 4.115024 25.638369 1.685339 19.772589   b -0.744346 13.906809 1.315648 7.114815 6.59471 3.587458   b 9.234241 1.82378 12.319162 1.117147 15.305624 1.411288   b 17.812949 1.658238 20.249586 2.61433 22.295555 4.242179   l 22.295555 -0{\\p0}"
local tethysIcon_speed = "{\\p1}m 0 0   m 28 28   m 14 2.053711   b 10.414212 2.053711 6.827634 3.417483 4.099609 6.145508   b -1.35644 11.601557 -1.35644 20.490239 4.099609 25.946289   l 6.017578 24.02832   b 1.597151 19.607893 1.597151 12.483903 6.017578 8.063476   b 10.438006 3.64305 17.561994 3.64305 21.982422 8.063476   b 26.402849 12.483903 26.402849 19.607893 21.982422 24.02832   l 23.900391 25.946289   b 29.35644 20.490239 29.35644 11.601557 23.900391 6.145508   b 21.172366 3.417483 17.585788 2.053711 14 2.053711   m 17.886719 10.034179   l 14.351562 13.571289   b 14.235118 13.554564 14.117639 13.54608 14 13.545898   b 13.336959 13.545898 12.701074 13.80929 12.232233 14.278131   b 11.763392 14.746972 11.5 15.382857 11.5 16.045898   b 11.5 17.42661 12.619288 18.545898 14 18.545898   b 14.663041 18.545898 15.298926 18.282506 15.767767 17.813665   b 16.236608 17.344824 16.5 16.708939 16.5 16.045898   b 16.499911 15.927607 16.491426 15.809472 16.47461 15.692382   l 20.009767 12.155273{\\p0}"
local tethysIcon_vol_033 = "{\\p1}m 0 0   m 28 28   m 4.710272 20.331519   l 1.360222 18.656494   b 0.489258 18.221011 0.489258 18.221011 0.489258 17.165758   l 0.489258 14   l 0.489258 10.83424   b 0.489258 9.778988 0.48926 9.778988 1.337532 9.354852   l 4.710272 7.668481   m 5.765524 7.674466   l 9.986538 3.453454   b 10.706239 2.706516 12.097044 1.342947 12.097044 3.453454   l 12.097044 24.558517   b 12.097044 26.669023 10.738402 25.263082 9.986538 24.558517   l 5.765524 20.337504   m 16.562393 10.929048   l 14.418911 13.150849   l 14.418911 14.870154   l 16.488207 17.07095   b 17.436586 16.089838 17.82417 15.024196 17.820228 13.983409   b 17.816228 12.942625 17.530838 11.909297 16.562404 10.929049{\\p0}"
local tethysIcon_vol_066 = "{\\p1}m 0 0   m 28 28   m 4.710272 20.331519   l 1.360222 18.656494   b 0.489258 18.221011 0.489258 18.221011 0.489258 17.165758   l 0.489258 14   l 0.489258 10.83424   b 0.489258 9.778988 0.48926 9.778988 1.337532 9.354852   l 4.710272 7.668481   m 5.765524 7.674466   l 9.986538 3.453454   b 10.706239 2.706516 12.097044 1.342947 12.097044 3.453454   l 12.097044 24.558517   b 12.097044 26.669023 10.738402 25.263082 9.986538 24.558517   l 5.765524 20.337504   m 20.116395 7.368459   l 17.915201 9.643849   b 18.793615 10.494225 19.496549 12.085227 19.477484 14.012366   b 19.458484 15.939505 18.683596 17.529199 17.842625 18.356568   l 20.064426 20.611347   b 21.82241 18.8818 22.618007 16.592612 22.643244 14.04122   b 22.668484 11.489827 21.937955 9.131882 20.116395 7.368459   m 16.562393 10.929048   l 14.418911 13.150849   l 14.418911 14.870154   l 16.488207 17.07095   b 17.436586 16.089838 17.82417 15.024196 17.820228 13.983409   b 17.816228 12.942625 17.530838 11.909297 16.562404 10.929049{\\p0}"
local tethysIcon_vol_100 = "{\\p1}m 0 0   m 28 28   m 4.710272 20.331519   l 1.360222 18.656494   b 0.489258 18.221011 0.489258 18.221011 0.489258 17.165758   l 0.489258 14   l 0.489258 10.83424   b 0.489258 9.778988 0.48926 9.778988 1.337532 9.354852   l 4.710272 7.668481   m 5.765524 7.674466   l 9.986538 3.453454   b 10.706239 2.706516 12.097044 1.342947 12.097044 3.453454   l 12.097044 24.558517   b 12.097044 26.669023 10.738402 25.263082 9.986538 24.558517   l 5.765524 20.337504   m 23.532835 3.779296   l 21.294544 6.017587   b 22.97216 7.695202 24.35259 10.812999 24.344937 13.990067   b 24.337337 17.167135 22.938039 20.301821 21.257445 21.982413   l 23.499858 24.220704   b 26.040275 21.680287 27.501508 17.812486 27.510697 13.99831   b 27.519997 10.184133 26.076229 6.322689 23.532835 3.779296   m 20.116395 7.368459   l 17.915201 9.643849   b 18.793615 10.494225 19.496549 12.085227 19.477484 14.012366   b 19.458484 15.939505 18.683596 17.529199 17.842625 18.356568   l 20.064426 20.611347   b 21.82241 18.8818 22.618007 16.592612 22.643244 14.04122   b 22.668484 11.489827 21.937955 9.131882 20.116395 7.368459   m 16.562393 10.929048   l 14.418911 13.150849   l 14.418911 14.870154   l 16.488207 17.07095   b 17.436586 16.089838 17.82417 15.024196 17.820228 13.983409   b 17.816228 12.942625 17.530838 11.909297 16.562404 10.929049{\\p0}"
local tethysIcon_vol_101 = "{\\p1}m 0 0   m 28 28   m 26.774083 5.201582   l 25.69218 18.248063   b 25.66035 18.693555 25.533063 18.916303 25.31033 18.916303   b 25.08759 18.916303 24.960302 18.693563 24.928482 18.248063   l 23.878399 5.201582   l 23.878399 5.074292   b 23.878399 4.660623 24.005689 4.342418 24.292068 4.119669   b 24.578454 3.865105 24.928482 3.737822 25.31033 3.737822   b 25.724 3.737822 26.042205 3.865111 26.328594 4.119669   b 26.614979 4.342409 26.774083 4.660623 26.774083 5.074292   m 26.774083 22.734783   b 26.774083 23.180275 26.614991 23.530301 26.360414 23.816689   b 26.074028 24.134895 25.724 24.262178 25.31033 24.262178   b 24.928482 24.262178 24.578454 24.134888 24.292068 23.816689   b 24.005682 23.530301 23.878399 23.180275 23.878399 22.734783   b 23.878399 22.321115 24.005689 21.971087 24.292068 21.684702   b 24.578454 21.366494 24.928482 21.239213 25.31033 21.239213   b 25.724 21.239213 26.074028 21.366487 26.360414 21.684702   b 26.614979 21.971087 26.774083 22.321115 26.774083 22.734783   m 4.710272 20.331519   l 1.360222 18.656494   b 0.489258 18.221011 0.489258 18.221011 0.489258 17.165758   l 0.489258 14   l 0.489258 10.83424   b 0.489258 9.778988 0.48926 9.778988 1.337532 9.354852   l 4.710272 7.668481   m 5.765524 7.674466   l 9.986538 3.453454   b 10.706239 2.706516 12.097044 1.342947 12.097044 3.453454   l 12.097044 24.558517   b 12.097044 26.669023 10.738402 25.263082 9.986538 24.558517   l 5.765524 20.337504   m 20.116395 7.368459   l 17.915201 9.643849   b 18.793615 10.494225 19.496549 12.085227 19.477484 14.012366   b 19.458484 15.939505 18.683596 17.529199 17.842625 18.356568   l 20.064426 20.611347   b 21.82241 18.8818 22.618007 16.592612 22.643244 14.04122   b 22.668484 11.489827 21.937955 9.131882 20.116395 7.368459   m 16.562393 10.929048   l 14.418911 13.150849   l 14.418911 14.870154   l 16.488207 17.07095   b 17.436586 16.089838 17.82417 15.024196 17.820228 13.983409   b 17.816228 12.942625 17.530838 11.909297 16.562404 10.929049{\\p0}"
local tethysIcon_vol_mute = "{\\p1}m 0 0   m 28 28   m 4.710272 20.331519   l 1.360222 18.656494   b 0.489258 18.221011 0.489258 18.221011 0.489258 17.165758   l 0.489258 14   l 0.489258 10.83424   b 0.489258 9.778988 0.48926 9.778988 1.337532 9.354852   l 4.710272 7.668481   m 5.765524 7.674466   l 9.986538 3.453454   b 10.706239 2.706516 12.097044 1.342947 12.097044 3.453454   l 12.097044 24.558517   b 12.097044 26.669023 10.738402 25.263082 9.986538 24.558517   l 5.765524 20.337504   m 26.699268 7.480125   b 26.905593 7.480125 27.111919 7.52139 27.276978 7.68645   b 27.607099 8.01657 27.607099 8.51175 27.276978 8.841871   l 22.077583 14.041265   l 27.276978 19.240659   b 27.565833 19.529515 27.565833 19.98343 27.276978 20.31355   b 26.988123 20.602406 26.492943 20.602406 26.204087 20.31355   l 21.004692 15.114157   l 15.805297 20.31355   b 15.516442 20.602406 14.979997 20.602406 14.691142 20.31355   b 14.361021 19.98343 14.361021 19.48825 14.691142 19.158129   l 19.849271 13.958735   l 14.649877 8.759341   b 14.361021 8.470485 14.361021 8.01657 14.649877 7.68645   b 14.979997 7.397594 15.433912 7.397594 15.764033 7.68645   l 20.963428 12.885844   l 26.162823 7.68645   b 26.286617 7.52139 26.492943 7.480125 26.699268 7.480125{\\p0}"

function scaleIcon(iconStr, iconScale)
    -- Match space before number to ignore {\p1} and {\p0}
    return iconStr:gsub(" ([%d%.]+)", function(numStr)
        local num = tonumber(numStr)
        num = num * iconScale
        return " " .. tostring(num)
    end)
end
local iconScale = tethys.controlsHeight / 64
if iconScale ~= 1 then
    tethysIcon_play = scaleIcon(tethysIcon_play, iconScale)
    tethysIcon_pause = scaleIcon(tethysIcon_pause, iconScale)
end
iconScale = tethys.windowButtonSize / 44
if iconScale ~= 1 then
    mpvOsdIcon_close = scaleIcon(mpvOsdIcon_close, iconScale)
    mpvOsdIcon_maximize = scaleIcon(mpvOsdIcon_maximize, iconScale)
    mpvOsdIcon_minimize = scaleIcon(mpvOsdIcon_minimize, iconScale)
    mpvOsdIcon_restore = scaleIcon(mpvOsdIcon_restore, iconScale)
end
iconScale = tethys.smallButtonSize / 42
if iconScale ~= 1 then
    mpvOsdIcon_fs_enter = scaleIcon(mpvOsdIcon_fs_enter, iconScale)
    mpvOsdIcon_fs_exit = scaleIcon(mpvOsdIcon_fs_exit, iconScale)
    tethysIcon_ch_prev = scaleIcon(tethysIcon_ch_prev, iconScale)
    tethysIcon_ch_next = scaleIcon(tethysIcon_ch_next, iconScale)
    tethysIcon_pip_enter = scaleIcon(tethysIcon_pip_enter, iconScale)
    tethysIcon_pip_exit = scaleIcon(tethysIcon_pip_exit, iconScale)
    tethysIcon_pl_prev = scaleIcon(tethysIcon_pl_prev, iconScale)
    tethysIcon_pl_next = scaleIcon(tethysIcon_pl_next, iconScale)
    tethysIcon_skipback = scaleIcon(tethysIcon_skipback, iconScale)
    tethysIcon_skipfrwd = scaleIcon(tethysIcon_skipfrwd, iconScale)
    tethysIcon_speed = scaleIcon(tethysIcon_speed, iconScale)
    tethysIcon_vol_033 = scaleIcon(tethysIcon_vol_033, iconScale)
    tethysIcon_vol_066 = scaleIcon(tethysIcon_vol_066, iconScale)
    tethysIcon_vol_100 = scaleIcon(tethysIcon_vol_100, iconScale)
    tethysIcon_vol_101 = scaleIcon(tethysIcon_vol_101, iconScale)
    tethysIcon_vol_mute = scaleIcon(tethysIcon_vol_mute, iconScale)
end



















--
-- Parameters
--
-- default user option values
-- do not touch, change them in osc.conf
local user_opts = {
    showwindowed = true,        -- show OSC when windowed?
    showfullscreen = true,      -- show OSC when fullscreen?
    idlescreen = true,          -- show mpv logo on idle
    scalewindowed = 1,          -- scaling of the controller when windowed
    scalefullscreen = 1,        -- scaling of the controller when fullscreen
    scaleforcedwindow = 2,      -- scaling when rendered on a forced window
    vidscale = true,            -- scale the controller with the video?
    valign = 0.8,               -- vertical alignment, -1 (top) to 1 (bottom)
    halign = 0,                 -- horizontal alignment, -1 (left) to 1 (right)
    barmargin = 0,              -- vertical margin of top/bottombar
    boxalpha = 80,              -- alpha of the background box,
                                -- 0 (opaque) to 255 (fully transparent)
    hidetimeout = 500,          -- duration in ms until the OSC hides if no
                                -- mouse movement. enforced non-negative for the
                                -- user, but internally negative is "always-on".
    fadeduration = 200,         -- duration of fade out in ms, 0 = no fade
    deadzonesize = 0.5,         -- size of deadzone
    minmousemove = 0,           -- minimum amount of pixels the mouse has to
                                -- move between ticks to make the OSC show up
    iamaprogrammer = false,     -- use native mpv values and disable OSC
                                -- internal track list management (and some
                                -- functions that depend on it)
    -- layout = "bottombar",
    layout = "tethys",
    seekbarstyle = "bar",       -- bar, diamond or knob
    seekbarhandlesize = 0.6,    -- size ratio of the diamond and knob handle
    seekrangestyle = "inverted",-- bar, line, slider, inverted or none
    seekrangeseparate = true,   -- whether the seekranges overlay on the bar-style seekbar
    seekrangealpha = 200,       -- transparency of seekranges
    seekbarkeyframes = true,    -- use keyframes when dragging the seekbar
    title = "${media-title}",   -- string compatible with property-expansion
                                -- to be shown as OSC title
    tooltipborder = 1,          -- border of tooltip in bottom/topbar
    timetotal = false,          -- display total time instead of remaining time?
    timems = false,             -- display timecodes with milliseconds?
    tcspace = 100, -- timecode spacing (compensate font size estimation)
    visibility = "auto",        -- only used at init to set visibility_mode(...)
    -- visibility = "always",        -- only used at init to set visibility_mode(...)
    boxmaxchars = 80,           -- title crop threshold for box layout
    boxvideo = false,           -- apply osc_param.video_margins to video
    windowcontrols = "auto",    -- whether to show window controls
    windowcontrols_alignment = "right", -- which side to show window controls on
    greenandgrumpy = false,     -- disable santa hat
    livemarkers = true,         -- update seekbar chapter markers on duration change
    chapters_osd = true,        -- whether to show chapters OSD on next/prev
    playlist_osd = true,        -- whether to show playlist OSD on next/prev
    chapter_fmt = "Chapter: %s", -- chapter print format for seekbar-hover. "no" to disable
    unicodeminus = false, -- whether to use the Unicode minus sign character
}

-- read options from config and command-line
opt.read_options(user_opts, "osc", function(list) update_options(list) end)

local osc_param = { -- calculated by osc_init()
    playresy = 0,                           -- canvas size Y
    playresx = 0,                           -- canvas size X
    display_aspect = 1,
    unscaled_y = 0,
    areas = {},
    video_margins = {
        l = 0, r = 0, t = 0, b = 0,         -- left/right/top/bottom
    },
}

local osc_styles = {
    bigButtons = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs50\\fnmpv-osd-symbols}",
    smallButtonsL = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs19\\fnmpv-osd-symbols}",
    smallButtonsLlabel = "{\\fscx105\\fscy105\\fn" .. mp.get_property("options/osd-font") .. "}",
    smallButtonsR = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs30\\fnmpv-osd-symbols}",
    topButtons = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs12\\fnmpv-osd-symbols}",

    elementDown = "{\\1c&H999999}",
    timecodes = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs20}",
    vidtitle = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs12\\q2}",
    box = "{\\rDefault\\blur0\\bord1\\1c&H000000\\3c&HFFFFFF}",

    topButtonsBar = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs18\\fnmpv-osd-symbols}",
    smallButtonsBar = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs28\\fnmpv-osd-symbols}",
    timecodesBar = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs27}",
    timePosBar = "{\\blur0\\bord".. user_opts.tooltipborder .."\\1c&HFFFFFF\\3c&H000000\\fs30}",
    vidtitleBar = "{\\blur0\\bord0\\1c&HFFFFFF\\3c&HFFFFFF\\fs18\\q2}",

    wcButtons = "{\\1c&HFFFFFF\\fs24\\fnmpv-osd-symbols}",
    wcTitle = "{\\1c&HFFFFFF\\fs24\\q2}",
    wcBar = "{\\1c&H000000}",
}


















---- Tooltip Utils
-- See MPV's stats.lua for a full example (Shortcut: I + 4)
-- https://github.com/mpv-player/mpv/blob/master/player/lua/stats.lua#L433
local bindings = mp.get_property_native("input-bindings", {})
local active = {}  -- map: key-name -> bind-info
for _, bind in pairs(bindings) do
    if bind.priority >= 0 and (
           not active[bind.key] or
           (active[bind.key].is_weak and not bind.is_weak) or
           (bind.is_weak == active[bind.key].is_weak and
            bind.priority > active[bind.key].priority)
       ) and not bind.cmd:find("script-binding stats/__forced_", 1, true)
    then
        active[bind.key] = bind
    end
end
local ordered = {}
for _, bind in pairs(active) do
    table.insert(ordered, bind)
    _,_, bind.mods = bind.key:find("(.*)%+.")
    _, bind.mods_count = bind.key:gsub("%+.", "")
end
table.sort(ordered, function(a, b)
    if a.subject ~= b.subject then
        return a.subject < b.subject
    elseif a.mods_count ~= b.mods_count then
        return a.mods_count < b.mods_count
    elseif a.mods ~= b.mods then
        return a.mods < b.mods
    elseif a.key:len() ~= b.key:len() then
        return a.key:len() < b.key:len()
    elseif a.key:lower() ~= b.key:lower() then
        return a.key:lower() < b.key:lower()
    else
        return a.key > b.key  -- only case differs, lowercase first
    end
end)
-- for _, bind in pairs(ordered) do
--     jsonstr, err = utils.format_json(bind)
--     print(jsonstr)
-- end

function isIgnored(bind, ignoredKeys)
    for _, ignoredKey in pairs(ignoredKeys) do
        if bind.key == ignoredKey then
            return true
        end
    end
    return false
end
function grepBindByCmd(pattern, ignoredKeys)
    ignoredKeys = ignoredKeys or {}
    local cmdBinds = {}
    for _, bind in pairs(ordered) do
        local ignored = isIgnored(bind, ignoredKeys)
        if not ignored and bind.cmd:find(pattern) then
            -- print(bind.key, bind.cmd)
            cmdBinds[#cmdBinds+1] = bind
        end
    end
    return cmdBinds
end

function grepSeekBinds(ignoredKeys)
    ignoredKeys = ignoredKeys or {}
    local backBinds = {}
    local frwdBinds = {}
    for _, bind in pairs(ordered) do
        if isIgnored(bind, ignoredKeys) then
            -- skip
        elseif bind.cmd:find("^seek(%s+)(%-[%d%.]+)") then
            backBinds[#backBinds+1] = bind
        elseif bind.cmd:find("^no%-osd(%s+)seek(%s+)(%-[%d%.]+)") then
            backBinds[#backBinds+1] = bind
        elseif bind.cmd:find("^seek(%s+)(%+?[%d%.]+)") then
            frwdBinds[#frwdBinds+1] = bind
        elseif bind.cmd:find("^no%-osd(%s+)seek(%s+)(%+?[%d%.]+)") then
            frwdBinds[#frwdBinds+1] = bind
        end
    end
    return backBinds, frwdBinds
end
function grepSpeedBinds(ignoredKeys)
    ignoredKeys = ignoredKeys or {}
    local downBinds = {}
    local upBinds = {}
    for _, bind in pairs(ordered) do
        if isIgnored(bind, ignoredKeys) then
            -- skip
        elseif bind.cmd:find("^add(%s+)speed(%s+)(%+?[%d%.]+)$") then
            upBinds[#upBinds+1] = bind
        elseif bind.cmd:find("^add(%s+)speed(%s+)(%-[%d%.]+)$") then
            downBinds[#downBinds+1] = bind
        elseif bind.cmd:find("^multiply(%s+)speed(%s+)([%d%.]+)/([%d%.]+)$") then
            local num, den = bind.cmd:match("^multiply%s+speed%s+([%d%.]+)/([%d%.]+)$")
            num = tonumber(num) -- numerator
            den = tonumber(den) -- denominator
            if num < den then
                downBinds[#downBinds+1] = bind
            else
                upBinds[#upBinds+1] = bind
            end
        elseif bind.cmd:find("^multiply(%s+)speed(%s+)([%d%.]+)$") then
            local x = bind.cmd:match("^multiply%s+speed%s+([%d%.]+)$")
            x = tonumber(x)
            if x < 1 then
                downBinds[#downBinds+1] = bind
            else
                upBinds[#upBinds+1] = bind
            end
        end
    end
    return downBinds, upBinds
end

function humanBindKey(key)
    if key == 'PGUP' then return 'PgUp'
    elseif key == 'PGDWN' then return 'PgDn'
    elseif key == 'UP' then return '⇧'
    elseif key == 'DOWN' then return '⇩'
    elseif key == 'LEFT' then return '⇦'
    elseif key == 'RIGHT' then return '⇨'
    elseif key == 'SHARP' then return '#'
    elseif key == 'BS' then return 'Backspace'
    elseif key == '{' then return '\\{'
    elseif key == '}' then return '\\}'
    else return key
    end
end
function formatBindKey(key)
    return tethysStyle.buttonKeybindFormat:format(humanBindKey(key))
end
function formatBinds(binds)
    local str = ""
    for i, bind in pairs(binds) do
        if i ~= 1 then -- lua arrays start at 1
            str = str .. " or "
        end
        str = str .. formatBindKey(bind.key)
    end
    return str
end
function formatSeekBind(bind)
    local seekBy
    if bind.cmd:match("^no%-osd%s+seek") then
        seekBy = bind.cmd:match("^no%-osd%s+seek%s+([%+%-]?[%d%.]+)")
    else
        seekBy = bind.cmd:match("^seek%s+([%+%-]?[%d%.]+)")
    end
    seekBy = tonumber(seekBy) -- Note: +0.1 is parsed okay
    local label
    if seekBy < 0 then
        return ("Back %ss %s"):format(-seekBy, formatBindKey(bind.key))
    else
        return ("Forward %ss %s"):format(seekBy, formatBindKey(bind.key))
    end
end
function formatSeekBinds(binds)
    local list = {}
    for i, bind in pairs(binds) do
        table.insert(list, formatSeekBind(bind))
    end
    return list
end

---- Filter bindings by commands using regex
---- Keys passed into grepBindByCmd() are ignored.
-- %s+ = One or more spaces
-- %- = A literal dash '-'
-- %-? = May or may not contain a dash
-- %d+ = One or more digits from 0 to 9
-- (%-?%d+) = Positive or negative integer
local pauseBinds = grepBindByCmd("^cycle(%s+)pause", {"p", "PLAYPAUSE", "MBTN_RIGHT", "PLAY", "PAUSE"})
local seekBackBinds, seekFrwdBinds = grepSeekBinds({"REWIND", "Shift+PGDWN", "FORWARD", "Shift+PGUP"})
local muteBinds = grepBindByCmd("^cycle(%s+)mute", {"MUTE"})
local volDnBinds = grepBindByCmd("^add(%s+)volume(%s+)(%-%d+)", {"VOLUME_DOWN", "WHEEL_LEFT"})
local volUpBinds = grepBindByCmd("^add(%s+)volume(%s+)(%d+)", {"VOLUME_UP", "WHEEL_RIGHT"})
local plPrevBinds = grepBindByCmd("^playlist%-prev", {"PREV", "MBTN_BACK"})
local plNextBinds = grepBindByCmd("^playlist%-next", {"NEXT", "MBTN_FORWARD"})
local chPrevBinds = grepBindByCmd("^add chapter (%-%d+)", {})
local chNextBinds = grepBindByCmd("^add chapter (%d+)", {})
local audioBinds = grepBindByCmd("^cycle(%s+)audio", {})
local subBinds = grepBindByCmd("^cycle(%s+)sub$", {})
local speedResetBinds = grepBindByCmd("^set(%s+)speed(%s+)1", {})
local speedDnBinds, speedUpBinds = grepSpeedBinds()
local fullscreenBinds = grepBindByCmd("^cycle(%s+)fullscreen", {"MBTN_LEFT_DBL"})
---- Generate tooltips
local pauseTooltip = ("Play %s"):format(formatBinds(pauseBinds))
local seekBackTooltip = formatSeekBinds(seekBackBinds)
local seekFrwdTooltip = formatSeekBinds(seekFrwdBinds)
local muteTooltip = formatBinds(muteBinds)
local volDnTooltip = formatBinds(volDnBinds)
local volUpTooltip = formatBinds(volUpBinds)
local volTooltip = ("Mute %s\\NVolume Up %s\\NVolume Down %s"):format(muteTooltip, volUpTooltip, volDnTooltip)
local plPrevTooltip = ("Previous %s"):format(formatBinds(plPrevBinds))
local plNextTooltip = ("Next %s"):format(formatBinds(plNextBinds))
local chPrevTooltip = ("Prev Chapter %s"):format(formatBinds(chPrevBinds))
local chNextTooltip = ("Next Chapter %s"):format(formatBinds(chNextBinds))
local audioTooltip = ("Audio Track %s"):format(formatBinds(audioBinds))
local subTooltip = ("Subtitle Track %s"):format(formatBinds(subBinds))
local speedResetTooltip = formatBinds(speedResetBinds)
local speedDnTooltip = formatBinds(speedDnBinds)
local speedUpTooltip = formatBinds(speedUpBinds)
local speedTooltip = ("Reset %s\\NFaster %s\\NSlower %s"):format(speedResetTooltip, speedUpTooltip, speedDnTooltip)
local pipTooltip = "Picture In Picture"
local fullscreenTooltip = ("Fullscreen %s"):format(formatBinds(fullscreenBinds))
-- print("pauseTooltip", pauseTooltip)
-- print("seekBackTooltip", utils.format_json(seekBackTooltip))
-- print("seekFrwdTooltip", utils.format_json(seekFrwdTooltip))
-- print("muteTooltip", muteTooltip)
-- print("volDnTooltip", volDnTooltip)
-- print("volUpTooltip", volUpTooltip)
-- print("volTooltip", utils.format_json(volTooltip))
-- print("plPrevTooltip", plPrevTooltip)
-- print("plNextTooltip", plNextTooltip)
-- print("chPrevTooltip", chPrevTooltip)
-- print("chNextTooltip", chNextTooltip)
-- print("audioTooltip", audioTooltip)
-- print("subTooltip", subTooltip)
-- print("speedResetTooltip", speedResetTooltip)
-- print("speedDnTooltip", speedDnTooltip)
-- print("speedUpTooltip", speedUpTooltip)
-- print("speedTooltip", utils.format_json(speedTooltip))
-- print("pipTooltip", pipTooltip)
-- print("fullscreenTooltip", fullscreenTooltip)



















---- Playlist / Chapter Utils
function getDeltaListItem(listKey, curKey, delta, clamp)
    local pos = mp.get_property_number(curKey, 0) + 1
    local count, limlist = limited_list(listKey, pos)
    if count == 0 then
        return nil
    end

    local curIndex = -1
    for i, v in ipairs(limlist) do
        if v.current then
            curIndex = i
            break
        end
    end

    local deltaIndex = curIndex + delta
    if curIndex == -1 then
        return nil
    elseif deltaIndex < 1 then
        if clamp then
            deltaIndex = 1
        else
            return nil
        end
    elseif deltaIndex > count then
        if clamp then
            deltaIndex = count
        else
            return nil
        end
    end

    local deltaItem = limlist[deltaIndex]
    return deltaIndex, deltaItem
end

function getDeltaChapter(delta)
    local deltaIndex, deltaChapter = getDeltaListItem('chapter-list', 'chapter', delta, true)
    if deltaChapter == nil then -- Video Done
        return nil
    end
    deltaChapter = {
        index = deltaIndex,
        time = deltaChapter.time,
        title = deltaChapter.title,
        label = nil,
    }
    local label = deltaChapter.title
    if label == nil then
        label = string.format('Chapter %02d', deltaChapter.index)
    end
    -- local time = mp.format_time(deltaChapter.time)
    -- deltaChapter.label = string.format('[%s] %s', time, label)
    deltaChapter.label = label
    return deltaChapter
end

function getDeltaPlaylistItem(delta)
    local deltaIndex, deltaItem = getDeltaListItem('playlist', 'playlist-pos', delta, false)
    if deltaItem == nil then
        return nil
    end
    deltaItem = {
        index = deltaIndex,
        filename = deltaItem.filename,
        title = deltaItem.title,
        label = nil,
    }
    local label = deltaItem.title
    if label == nil then
        local _, filename = utils.split_path(deltaItem.filename)
        label = filename
    end
    deltaItem.label = label
    return deltaItem
end



















---- Thumbnailer (https://github.com/TheAMM/mpv_thumbnail_script)
-- mpv_thumbnail_script/lib/helpers.lua
-- (partial file) Only copied the needed functions
function clear_table(target)
  for key, value in pairs(target) do
    target[key] = nil
  end
end
ON_WINDOWS = (package.config:sub(1,1) ~= '/')
function is_absolute_path( path )
  local tmp, is_win  = path:gsub("^[A-Z]:\\", "")
  local tmp, is_unix = path:gsub("^/", "")
  return (is_win > 0) or (is_unix > 0)
end
function join_paths(...)
  local sep = ON_WINDOWS and "\\" or "/"
  local result = "";
  for i, p in pairs({...}) do
    if p ~= "" then
      if is_absolute_path(p) then
        result = p
      else
        result = (result ~= "") and (result:gsub("[\\"..sep.."]*$", "") .. sep .. p) or p
      end
    end
  end
  return result:gsub("[\\"..sep.."]*$", "")
end
function create_directories(path)
  local cmd
  if ON_WINDOWS then
    cmd = { args = {"cmd", "/c", "mkdir", path} }
  else
    cmd = { args = {"mkdir", "-p", path} }
  end
  utils.subprocess(cmd)
end
function file_exists(name)
  local f = io.open(name, "rb")
  if f ~= nil then
    local ok, err, code = f:read(1)
    io.close(f)
    return code == nil
  else
    return false
  end
end
-- Find an executable in PATH or CWD with the given name
function find_executable(name)
  local delim = ON_WINDOWS and ";" or ":"
  local pwd = os.getenv("PWD") or utils.getcwd()
  local path = os.getenv("PATH")
  local env_path = pwd .. delim .. path -- Check CWD first
  local result, filename
  for path_dir in env_path:gmatch("[^"..delim.."]+") do
    filename = join_paths(path_dir, name)
    if file_exists(filename) then
      result = filename
      break
    end
  end
  return result
end
-- Searches for an executable and caches the result if any
local ExecutableFinder = { path_cache = {} }
function ExecutableFinder:get_executable_path(name, raw_name)
  name = ON_WINDOWS and not raw_name and (name .. ".exe") or name
  if self.path_cache[name] == nil then
    self.path_cache[name] = find_executable(name) or false
  end
  return self.path_cache[name]
end



-- mpv_thumbnail_script/lib/sha1.lua
-- $Revision: 1.5 $
-- $Date: 2014-09-10 16:54:25 $

-- This module was originally taken from http://cube3d.de/uploads/Main/sha1.txt.

-------------------------------------------------------------------------------
-- SHA-1 secure hash computation, and HMAC-SHA1 signature computation,
-- in pure Lua (tested on Lua 5.1)
-- License: MIT
--
-- Usage:
-- local hashAsHex = sha1.hex(message) -- returns a hex string
-- local hashAsData = sha1.bin(message) -- returns raw bytes
--
-- local hmacAsHex = sha1.hmacHex(key, message) -- hex string
-- local hmacAsData = sha1.hmacBin(key, message) -- raw bytes
--
--
-- Pass sha1.hex() a string, and it returns a hash as a 40-character hex string.
-- For example, the call
--
-- local hash = sha1.hex("iNTERFACEWARE")
--
-- puts the 40-character string
--
-- "e76705ffb88a291a0d2f9710a5471936791b4819"
--
-- into the variable 'hash'
--
-- Pass sha1.hmacHex() a key and a message, and it returns the signature as a
-- 40-byte hex string.
--
--
-- The two "bin" versions do the same, but return the 20-byte string of raw
-- data that the 40-byte hex strings represent.
--
-------------------------------------------------------------------------------
--
-- Description
-- Due to the lack of bitwise operations in 5.1, this version uses numbers to
-- represents the 32bit words that we combine with binary operations. The basic
-- operations of byte based "xor", "or", "and" are all cached in a combination
-- table (several 64k large tables are built on startup, which
-- consumes some memory and time). The caching can be switched off through
-- setting the local cfg_caching variable to false.
-- For all binary operations, the 32 bit numbers are split into 8 bit values
-- that are combined and then merged again.
--
-- Algorithm: http://www.itl.nist.gov/fipspubs/fip180-1.htm
--
-------------------------------------------------------------------------------

local sha1 = (function()
local sha1 = {}

-- set this to false if you don't want to build several 64k sized tables when
-- loading this file (takes a while but grants a boost of factor 13)
local cfg_caching = false
-- local storing of global functions (minor speedup)
local floor,modf = math.floor,math.modf
local char,format,rep = string.char,string.format,string.rep

-- merge 4 bytes to an 32 bit word
local function bytes_to_w32 (a,b,c,d) return a*0x1000000+b*0x10000+c*0x100+d end
-- split a 32 bit word into four 8 bit numbers
local function w32_to_bytes (i)
   return floor(i/0x1000000)%0x100,floor(i/0x10000)%0x100,floor(i/0x100)%0x100,i%0x100
end

-- shift the bits of a 32 bit word. Don't use negative values for "bits"
local function w32_rot (bits,a)
   local b2 = 2^(32-bits)
   local a,b = modf(a/b2)
   return a+b*b2*(2^(bits))
end

-- caching function for functions that accept 2 arguments, both of values between
-- 0 and 255. The function to be cached is passed, all values are calculated
-- during loading and a function is returned that returns the cached values (only)
local function cache2arg (fn)
   if not cfg_caching then return fn end
   local lut = {}
   for i=0,0xffff do
      local a,b = floor(i/0x100),i%0x100
      lut[i] = fn(a,b)
   end
   return function (a,b)
      return lut[a*0x100+b]
   end
end

-- splits an 8-bit number into 8 bits, returning all 8 bits as booleans
local function byte_to_bits (b)
   local b = function (n)
      local b = floor(b/n)
      return b%2==1
   end
   return b(1),b(2),b(4),b(8),b(16),b(32),b(64),b(128)
end

-- builds an 8bit number from 8 booleans
local function bits_to_byte (a,b,c,d,e,f,g,h)
   local function n(b,x) return b and x or 0 end
   return n(a,1)+n(b,2)+n(c,4)+n(d,8)+n(e,16)+n(f,32)+n(g,64)+n(h,128)
end

-- debug function for visualizing bits in a string
local function bits_to_string (a,b,c,d,e,f,g,h)
   local function x(b) return b and "1" or "0" end
   return ("%s%s%s%s %s%s%s%s"):format(x(a),x(b),x(c),x(d),x(e),x(f),x(g),x(h))
end

-- debug function for converting a 8-bit number as bit string
local function byte_to_bit_string (b)
   return bits_to_string(byte_to_bits(b))
end

-- debug function for converting a 32 bit number as bit string
local function w32_to_bit_string(a)
   if type(a) == "string" then return a end
   local aa,ab,ac,ad = w32_to_bytes(a)
   local s = byte_to_bit_string
   return ("%s %s %s %s"):format(s(aa):reverse(),s(ab):reverse(),s(ac):reverse(),s(ad):reverse()):reverse()
end

-- bitwise "and" function for 2 8bit number
local band = cache2arg (function(a,b)
      local A,B,C,D,E,F,G,H = byte_to_bits(b)
      local a,b,c,d,e,f,g,h = byte_to_bits(a)
      return bits_to_byte(
         A and a, B and b, C and c, D and d,
         E and e, F and f, G and g, H and h)
   end)

-- bitwise "or" function for 2 8bit numbers
local bor = cache2arg(function(a,b)
      local A,B,C,D,E,F,G,H = byte_to_bits(b)
      local a,b,c,d,e,f,g,h = byte_to_bits(a)
      return bits_to_byte(
         A or a, B or b, C or c, D or d,
         E or e, F or f, G or g, H or h)
   end)

-- bitwise "xor" function for 2 8bit numbers
local bxor = cache2arg(function(a,b)
      local A,B,C,D,E,F,G,H = byte_to_bits(b)
      local a,b,c,d,e,f,g,h = byte_to_bits(a)
      return bits_to_byte(
         A ~= a, B ~= b, C ~= c, D ~= d,
         E ~= e, F ~= f, G ~= g, H ~= h)
   end)

-- bitwise complement for one 8bit number
local function bnot (x)
   return 255-(x % 256)
end

-- creates a function to combine to 32bit numbers using an 8bit combination function
local function w32_comb(fn)
   return function (a,b)
      local aa,ab,ac,ad = w32_to_bytes(a)
      local ba,bb,bc,bd = w32_to_bytes(b)
      return bytes_to_w32(fn(aa,ba),fn(ab,bb),fn(ac,bc),fn(ad,bd))
   end
end

-- create functions for and, xor and or, all for 2 32bit numbers
local w32_and = w32_comb(band)
local w32_xor = w32_comb(bxor)
local w32_or = w32_comb(bor)

-- xor function that may receive a variable number of arguments
local function w32_xor_n (a,...)
   local aa,ab,ac,ad = w32_to_bytes(a)
   for i=1,select('#',...) do
      local ba,bb,bc,bd = w32_to_bytes(select(i,...))
      aa,ab,ac,ad = bxor(aa,ba),bxor(ab,bb),bxor(ac,bc),bxor(ad,bd)
   end
   return bytes_to_w32(aa,ab,ac,ad)
end

-- combining 3 32bit numbers through binary "or" operation
local function w32_or3 (a,b,c)
   local aa,ab,ac,ad = w32_to_bytes(a)
   local ba,bb,bc,bd = w32_to_bytes(b)
   local ca,cb,cc,cd = w32_to_bytes(c)
   return bytes_to_w32(
      bor(aa,bor(ba,ca)), bor(ab,bor(bb,cb)), bor(ac,bor(bc,cc)), bor(ad,bor(bd,cd))
   )
end

-- binary complement for 32bit numbers
local function w32_not (a)
   return 4294967295-(a % 4294967296)
end

-- adding 2 32bit numbers, cutting off the remainder on 33th bit
local function w32_add (a,b) return (a+b) % 4294967296 end

-- adding n 32bit numbers, cutting off the remainder (again)
local function w32_add_n (a,...)
   for i=1,select('#',...) do
      a = (a+select(i,...)) % 4294967296
   end
   return a
end
-- converting the number to a hexadecimal string
local function w32_to_hexstring (w) return format("%08x",w) end

-- calculating the SHA1 for some text
function sha1.hex(msg)
   local H0,H1,H2,H3,H4 = 0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0
   local msg_len_in_bits = #msg * 8

   local first_append = char(0x80) -- append a '1' bit plus seven '0' bits

   local non_zero_message_bytes = #msg +1 +8 -- the +1 is the appended bit 1, the +8 are for the final appended length
   local current_mod = non_zero_message_bytes % 64
   local second_append = current_mod>0 and rep(char(0), 64 - current_mod) or ""

   -- now to append the length as a 64-bit number.
   local B1, R1 = modf(msg_len_in_bits / 0x01000000)
   local B2, R2 = modf( 0x01000000 * R1 / 0x00010000)
   local B3, R3 = modf( 0x00010000 * R2 / 0x00000100)
   local B4 = 0x00000100 * R3

   local L64 = char( 0) .. char( 0) .. char( 0) .. char( 0) -- high 32 bits
   .. char(B1) .. char(B2) .. char(B3) .. char(B4) -- low 32 bits

   msg = msg .. first_append .. second_append .. L64

   assert(#msg % 64 == 0)

   local chunks = #msg / 64

   local W = { }
   local start, A, B, C, D, E, f, K, TEMP
   local chunk = 0

   while chunk < chunks do
      --
      -- break chunk up into W[0] through W[15]
      --
      start,chunk = chunk * 64 + 1,chunk + 1

      for t = 0, 15 do
         W[t] = bytes_to_w32(msg:byte(start, start + 3))
         start = start + 4
      end

      --
      -- build W[16] through W[79]
      --
      for t = 16, 79 do
         -- For t = 16 to 79 let Wt = S1(Wt-3 XOR Wt-8 XOR Wt-14 XOR Wt-16).
         W[t] = w32_rot(1, w32_xor_n(W[t-3], W[t-8], W[t-14], W[t-16]))
      end

      A,B,C,D,E = H0,H1,H2,H3,H4

      for t = 0, 79 do
         if t <= 19 then
            -- (B AND C) OR ((NOT B) AND D)
            f = w32_or(w32_and(B, C), w32_and(w32_not(B), D))
            K = 0x5A827999
         elseif t <= 39 then
            -- B XOR C XOR D
            f = w32_xor_n(B, C, D)
            K = 0x6ED9EBA1
         elseif t <= 59 then
            -- (B AND C) OR (B AND D) OR (C AND D
            f = w32_or3(w32_and(B, C), w32_and(B, D), w32_and(C, D))
            K = 0x8F1BBCDC
         else
            -- B XOR C XOR D
            f = w32_xor_n(B, C, D)
            K = 0xCA62C1D6
         end

         -- TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;
         A,B,C,D,E = w32_add_n(w32_rot(5, A), f, E, W[t], K),
         A, w32_rot(30, B), C, D
      end
      -- Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.
      H0,H1,H2,H3,H4 = w32_add(H0, A),w32_add(H1, B),w32_add(H2, C),w32_add(H3, D),w32_add(H4, E)
   end
   local f = w32_to_hexstring
   return f(H0) .. f(H1) .. f(H2) .. f(H3) .. f(H4)
end

local function hex_to_binary(hex)
   return hex:gsub('..', function(hexval)
         return string.char(tonumber(hexval, 16))
      end)
end

function sha1.bin(msg)
   return hex_to_binary(sha1.hex(msg))
end

local xor_with_0x5c = {}
local xor_with_0x36 = {}
-- building the lookuptables ahead of time (instead of littering the source code
-- with precalculated values)
for i=0,0xff do
   xor_with_0x5c[char(i)] = char(bxor(i,0x5c))
   xor_with_0x36[char(i)] = char(bxor(i,0x36))
end

local blocksize = 64 -- 512 bits

function sha1.hmacHex(key, text)
   assert(type(key) == 'string', "key passed to hmacHex should be a string")
   assert(type(text) == 'string', "text passed to hmacHex should be a string")

   if #key > blocksize then
      key = sha1.bin(key)
   end

   local key_xord_with_0x36 = key:gsub('.', xor_with_0x36) .. string.rep(string.char(0x36), blocksize - #key)
   local key_xord_with_0x5c = key:gsub('.', xor_with_0x5c) .. string.rep(string.char(0x5c), blocksize - #key)

   return sha1.hex(key_xord_with_0x5c .. sha1.bin(key_xord_with_0x36 .. text))
end

function sha1.hmacBin(key, text)
   return hex_to_binary(sha1.hmacHex(key, text))
end

return sha1
end)()



-- mpv_thumbnail_script/src/options.lua
local SCRIPT_NAME = "mpv_thumbnail_script"

local default_cache_base = ON_WINDOWS and os.getenv("TEMP") or "/tmp/"

local thumbnailer_options = {
    -- The thumbnail directory
    cache_directory = join_paths(default_cache_base, "mpv_thumbs_cache"),

    ------------------------
    -- Generation options --
    ------------------------

    -- Automatically generate the thumbnails on video load, without a keypress
    autogenerate = true,

    -- Only automatically thumbnail videos shorter than this (seconds)
    autogenerate_max_duration = 3600, -- 1 hour

    -- SHA1-sum filenames over this length
    -- It's nice to know what files the thumbnails are (hence directory names)
    -- but long URLs may approach filesystem limits.
    hash_filename_length = 128,

    -- Use mpv to generate thumbnail even if ffmpeg is found in PATH
    -- ffmpeg does not handle ordered chapters (MKVs which rely on other MKVs)!
    -- mpv is a bit slower, but has better support overall (eg. subtitles in the previews)
    prefer_mpv = true,

    -- Explicitly disable subtitles on the mpv sub-calls
    mpv_no_sub = false,
    -- Add a "--no-config" to the mpv sub-call arguments
    mpv_no_config = false,
    -- Add a "--profile=<mpv_profile>" to the mpv sub-call arguments
    -- Use "" to disable
    mpv_profile = "",
    -- Output debug logs to <thumbnail_path>.log, ala <cache_directory>/<video_filename>/000000.bgra.log
    -- The logs are removed after successful encodes, unless you set mpv_keep_logs below
    mpv_logs = true,
    -- Keep all mpv logs, even the succesfull ones
    mpv_keep_logs = false,

    -- Disable the built-in keybind ("T") to add your own
    disable_keybinds = false,

    ---------------------
    -- Display options --
    ---------------------

    -- Move the thumbnail up or down
    -- For example:
    --   topbar/bottombar: 24
    --   rest: 0
    vertical_offset = 24,

    -- Adjust background padding
    -- Examples:
    --   topbar:       0, 10, 10, 10
    --   bottombar:   10,  0, 10, 10
    --   slimbox/box: 10, 10, 10, 10
    pad_top   = 10,
    pad_bot   =  0,
    pad_left  = 10,
    pad_right = 10,

    -- If true, pad values are screen-pixels. If false, video-pixels.
    pad_in_screenspace = true,
    -- Calculate pad into the offset
    offset_by_pad = true,

    -- Background color in BBGGRR
    background_color = "000000",
    -- Alpha: 0 - fully opaque, 255 - transparent
    background_alpha = 80,

    -- Keep thumbnail on the screen near left or right side
    constrain_to_screen = true,

    -- Do not display the thumbnailing progress
    hide_progress = false,

    -----------------------
    -- Thumbnail options --
    -----------------------

    -- The maximum dimensions of the thumbnails (pixels)
    thumbnail_width = 200,
    thumbnail_height = 200,

    -- The thumbnail count target
    -- (This will result in a thumbnail every ~10 seconds for a 25 minute video)
    thumbnail_count = 150,

    -- The above target count will be adjusted by the minimum and
    -- maximum time difference between thumbnails.
    -- The thumbnail_count will be used to calculate a target separation,
    -- and min/max_delta will be used to constrict it.

    -- In other words, thumbnails will be:
    --   at least min_delta seconds apart (limiting the amount)
    --   at most max_delta seconds apart (raising the amount if needed)
    min_delta = 5,
    -- 120 seconds aka 2 minutes will add more thumbnails when the video is over 5 hours!
    max_delta = 90,


    -- Overrides for remote urls (you generally want less thumbnails!)
    -- Thumbnailing network paths will be done with mpv

    -- Allow thumbnailing network paths (naive check for "://")
    thumbnail_network = false,
    -- Override thumbnail count, min/max delta
    remote_thumbnail_count = 60,
    remote_min_delta = 15,
    remote_max_delta = 120,

    -- Try to grab the raw stream and disable ytdl for the mpv subcalls
    -- Much faster than passing the url to ytdl again, but may cause problems with some sites
    remote_direct_stream = true,
}

read_options(thumbnailer_options, SCRIPT_NAME)



-- mpv_thumbnail_script/src/thumbnailer_shared.lua
local Thumbnailer = {
    cache_directory = thumbnailer_options.cache_directory,

    state = {
        ready = false,
        available = false,
        enabled = false,

        thumbnail_template = nil,

        thumbnail_delta = nil,
        thumbnail_count = 0,

        thumbnail_size = nil,

        finished_thumbnails = 0,

        -- List of thumbnail states (from 1 to thumbnail_count)
        -- ready: 1
        -- in progress: 0
        -- not ready: -1
        thumbnails = {},

        worker_input_path = nil,
        -- Extra options for the workers
        worker_extra = {},
    },
    -- Set in register_client
    worker_register_timeout = nil,
    -- A timer used to wait for more workers in case we have none
    worker_wait_timer = nil,
    workers = {}
}

function Thumbnailer:clear_state()
    clear_table(self.state)
    self.state.ready = false
    self.state.available = false
    self.state.finished_thumbnails = 0
    self.state.thumbnails = {}
    self.state.worker_extra = {}
end


function Thumbnailer:on_file_loaded()
    self:clear_state()
end

function Thumbnailer:on_thumb_ready(index)
    self.state.thumbnails[index] = 1

    -- Full recount instead of a naive increment (let's be safe!)
    self.state.finished_thumbnails = 0
    for i, v in pairs(self.state.thumbnails) do
        if v > 0 then
            self.state.finished_thumbnails = self.state.finished_thumbnails + 1
        end
    end
end

function Thumbnailer:on_thumb_progress(index)
    if self.state.thumbnails[index] == nil then
        msg.warn("self.state.thumbnails[index] == nil", index, "count", #self.state.thumbnails)
        return
    end
    self.state.thumbnails[index] = math.max(self.state.thumbnails[index], 0)
end

function Thumbnailer:on_start_file()
    -- Clear state when a new file is being loaded
    self:clear_state()
end

function Thumbnailer:on_video_change(params)
    -- Gather a new state when we get proper video-dec-params and our state is empty
    if params ~= nil then
        if not self.state.ready then
            self:update_state()
        end
    end
end


function Thumbnailer:update_state()
    msg.debug("Gathering video/thumbnail state")

    self.state.thumbnail_delta = self:get_delta()
    self.state.thumbnail_count = self:get_thumbnail_count(self.state.thumbnail_delta)

    -- Prefill individual thumbnail states
    for i = 1, self.state.thumbnail_count do
        self.state.thumbnails[i] = -1
    end

    self.state.thumbnail_template, self.state.thumbnail_directory = self:get_thumbnail_template()
    self.state.thumbnail_size = self:get_thumbnail_size()

    self.state.ready = true

    local file_path = mp.get_property_native("path")
    self.state.is_remote = file_path:find("://") ~= nil

    self.state.available = false

    -- Make sure the file has video (and not just albumart)
    local track_list = mp.get_property_native("track-list")
    local has_video = false
    for i, track in pairs(track_list) do
        if track.type == "video" and not track.external and not track.albumart then
            has_video = true
            break
        end
    end

    if has_video and self.state.thumbnail_delta ~= nil and self.state.thumbnail_size ~= nil and self.state.thumbnail_count > 0 then
        self.state.available = true
    end

    msg.debug("Thumbnailer.state:", utils.to_string(self.state))

end


function Thumbnailer:get_thumbnail_template()
    local file_path = mp.get_property_native("path")
    local is_remote = file_path:find("://") ~= nil

    local filename = mp.get_property_native("filename/no-ext")
    local filesize = mp.get_property_native("file-size", 0)

    if is_remote then
        filesize = 0
    end

    filename = filename:gsub('[^a-zA-Z0-9_.%-\' ]', '')
    -- Hash overly long filenames (most likely URLs)
    if #filename > thumbnailer_options.hash_filename_length then
        filename = sha1.hex(filename)
    end

    local file_key = ("%s-%d"):format(filename, filesize)

    local thumbnail_directory = join_paths(self.cache_directory, file_key)
    local file_template = join_paths(thumbnail_directory, "%06d.bgra")
    return file_template, thumbnail_directory
end


function Thumbnailer:get_thumbnail_size()
    local video_dec_params = mp.get_property_native("video-dec-params")
    if video_dec_params == nil then
        return nil
    end
    local video_width = video_dec_params.dw
    local video_height = video_dec_params.dh
    if not (video_width and video_height) then
        return nil
    end

    local w, h
    if video_width > video_height then
        w = thumbnailer_options.thumbnail_width
        h = math.floor(video_height * (w / video_width))
    else
        h = thumbnailer_options.thumbnail_height
        w = math.floor(video_width * (h / video_height))
    end
    return { w=w, h=h }
end


function Thumbnailer:get_delta()
    local file_path = mp.get_property_native("path")
    local file_duration = mp.get_property_native("duration")
    local is_seekable = mp.get_property_native("seekable")

    -- Naive url check
    local is_remote = file_path:find("://") ~= nil

    local remote_and_disallowed = is_remote
    if is_remote and thumbnailer_options.thumbnail_network then
        remote_and_disallowed = false
    end

    if remote_and_disallowed or not is_seekable or not file_duration then
        -- Not a local path (or remote thumbnails allowed), not seekable or lacks duration
        return nil
    end

    local thumbnail_count = thumbnailer_options.thumbnail_count
    local min_delta = thumbnailer_options.min_delta
    local max_delta = thumbnailer_options.max_delta

    if is_remote then
        thumbnail_count = thumbnailer_options.remote_thumbnail_count
        min_delta = thumbnailer_options.remote_min_delta
        max_delta = thumbnailer_options.remote_max_delta
    end

    local target_delta = (file_duration / thumbnail_count)
    local delta = math.max(min_delta, math.min(max_delta, target_delta))

    return delta
end


function Thumbnailer:get_thumbnail_count(delta)
    if delta == nil then
        return 0
    end
    local file_duration = mp.get_property_native("duration")

    return math.ceil(file_duration / delta)
end

function Thumbnailer:get_closest(thumbnail_index)
    -- Given a 1-based index, find the closest available thumbnail and return it's 1-based index

    -- Check the direct thumbnail index first
    if self.state.thumbnails[thumbnail_index] > 0 then
        return thumbnail_index
    end

    local min_distance = self.state.thumbnail_count + 1
    local closest = nil

    -- Naive, inefficient, lazy. But functional.
    for index, value in pairs(self.state.thumbnails) do
        local distance = math.abs(index - thumbnail_index)
        if distance < min_distance and value > 0 then
            min_distance = distance
            closest = index
        end
    end
    return closest
end

function Thumbnailer:get_thumbnail_index(time_position)
    -- Returns a 1-based thumbnail index for the given timestamp (between 1 and thumbnail_count, inclusive)
    if self.state.thumbnail_delta and (self.state.thumbnail_count and self.state.thumbnail_count > 0) then
        return math.min(math.floor(time_position / self.state.thumbnail_delta) + 1, self.state.thumbnail_count)
    else
        return nil
    end
end

function Thumbnailer:get_thumbnail_path(time_position)
    -- Given a timestamp, return:
    --   the closest available thumbnail path (if any)
    --   the 1-based thumbnail index calculated from the timestamp
    --   the 1-based thumbnail index of the closest available (and used) thumbnail
    -- OR nil if thumbnails are not available.

    local thumbnail_index = self:get_thumbnail_index(time_position)
    if not thumbnail_index then return nil end

    local closest = self:get_closest(thumbnail_index)

    if closest ~= nil then
        return self.state.thumbnail_template:format(closest-1), thumbnail_index, closest
    else
        return nil, thumbnail_index, nil
    end
end

function Thumbnailer:register_client()
    self.worker_register_timeout = mp.get_time() + 2

    mp.register_script_message("mpv_thumbnail_script-ready", function(index, path)
        self:on_thumb_ready(tonumber(index), path)
    end)
    mp.register_script_message("mpv_thumbnail_script-progress", function(index, path)
        self:on_thumb_progress(tonumber(index), path)
    end)

    mp.register_script_message("mpv_thumbnail_script-worker", function(worker_name)
        if not self.workers[worker_name] then
            msg.debug("Registered worker", worker_name)
            self.workers[worker_name] = true
            mp.commandv("script-message-to", worker_name, "mpv_thumbnail_script-slaved")
        end
    end)

    -- Notify workers to generate thumbnails when video loads/changes
    -- This will be executed after the on_video_change (because it's registered after it)
    mp.observe_property("video-dec-params", "native", function()
        local duration = mp.get_property_native("duration")
        local max_duration = thumbnailer_options.autogenerate_max_duration

        if duration ~= nil and self.state.available and thumbnailer_options.autogenerate then
            -- Notify if autogenerate is on and video is not too long
            if duration < max_duration or max_duration == 0 then
                self:start_worker_jobs()
            end
        end
    end)

    local thumb_script_key = not thumbnailer_options.disable_keybinds and "T" or nil
    mp.add_key_binding(thumb_script_key, "generate-thumbnails", function()
        if self.state.available then
            mp.osd_message("Started thumbnailer jobs")
            self:start_worker_jobs()
        else
            mp.osd_message("Thumbnailing unavailable")
        end
    end)
end

function Thumbnailer:_create_thumbnail_job_order()
    -- Returns a list of 1-based thumbnail indices in a job order
    local used_frames = {}
    local work_frames = {}

    -- Pick frames in increasing frequency.
    -- This way we can do a quick few passes over the video and then fill in the gaps.
    for x = 6, 0, -1 do
        local nth = (2^x)

        for thi = 1, self.state.thumbnail_count, nth do
            if not used_frames[thi] then
                table.insert(work_frames, thi)
                used_frames[thi] = true
            end
        end
    end
    return work_frames
end

function Thumbnailer:prepare_source_path()
    local file_path = mp.get_property_native("path")

    if self.state.is_remote and thumbnailer_options.remote_direct_stream then
        -- Use the direct stream (possibly) provided by ytdl
        -- This skips ytdl on the sub-calls, making the thumbnailing faster
        -- Works well on YouTube, rest not really tested
        file_path = mp.get_property_native("stream-path")
        file_path = file_path:gsub(",ytdl_description.+", "")

        -- edl:// urls can get LONG. In which case, save the path (URL)
        -- to a temporary file and use that instead.
        local playlist_filename = join_paths(self.state.thumbnail_directory, "playlist.txt")

        if #file_path > 8000 then
            -- Path is too long for a playlist - just pass the original URL to
            -- workers and allow ytdl
            self.state.worker_extra.enable_ytdl = true
            file_path = mp.get_property_native("path")
            msg.warn("Falling back to original URL and ytdl due to LONG source path. This will be slow.")

        elseif #file_path > 1024 then
            local playlist_file = io.open(playlist_filename, "wb")
            if not playlist_file then
                msg.error(("Tried to write a playlist to %s but couldn't!"):format(playlist_file))
                return false
            end

            playlist_file:write(file_path .. "\n")
            playlist_file:close()

            file_path = "--playlist=" .. playlist_filename
            msg.warn("Using playlist workaround due to long source path")
        end
    end

    self.state.worker_input_path = file_path
    return true
end

function Thumbnailer:start_worker_jobs()
    -- Create directory for the thumbnails, if needed
    local l, err = utils.readdir(self.state.thumbnail_directory)
    if err then
        msg.debug("Creating thumbnail directory", self.state.thumbnail_directory)
        create_directories(self.state.thumbnail_directory)
    end

    -- Try to prepare the source path for workers, and bail if unable to do so
    if not self:prepare_source_path() then
        return
    end

    local worker_list = {}
    for worker_name in pairs(self.workers) do table.insert(worker_list, worker_name) end

    local worker_count = #worker_list

    -- In case we have a worker timer created already, clear it
    -- (For example, if the video-dec-params change in quick succession or the user pressed T, etc)
    if self.worker_wait_timer then
        self.worker_wait_timer:stop()
    end

    if worker_count == 0 then
        local now = mp.get_time()
        if mp.get_time() > self.worker_register_timeout then
            -- Workers have had their time to register but we have none!
            local err = "No thumbnail workers found. Make sure you are not missing a script!"
            msg.error(err)
            mp.osd_message(err, 3)

        else
            -- We may be too early. Delay the work start a bit to try again.
            msg.warn("No workers found. Waiting a bit more for them.")
            -- Wait at least half a second
            local wait_time = math.max(self.worker_register_timeout - now, 0.5)
            self.worker_wait_timer = mp.add_timeout(wait_time, function() self:start_worker_jobs() end)
        end

    else
        -- We have at least one worker. This may not be all of them, but they have had
        -- their time to register; we've done our best waiting for them.
        self.state.enabled = true

        msg.debug( ("Splitting %d thumbnails amongst %d worker(s)"):format(self.state.thumbnail_count, worker_count) )

        local frame_job_order = self:_create_thumbnail_job_order()
        local worker_jobs = {}
        for i = 1, worker_count do worker_jobs[worker_list[i]] = {} end

        -- Split frames amongst the workers
        for i, thumbnail_index in ipairs(frame_job_order) do
            local worker_id = worker_list[ ((i-1) % worker_count) + 1 ]
            table.insert(worker_jobs[worker_id], thumbnail_index)
        end

        local state_json_string = utils.format_json(self.state)
        msg.debug("Giving workers state:", state_json_string)

        for worker_name, worker_frames in pairs(worker_jobs) do
            if #worker_frames > 0 then
                local frames_json_string = utils.format_json(worker_frames)
                msg.debug("Assigning job to", worker_name, frames_json_string)
                mp.commandv("script-message-to", worker_name, "mpv_thumbnail_script-job", state_json_string, frames_json_string)
            end
        end
    end
end

mp.register_event("start-file", function() Thumbnailer:on_start_file() end)
mp.observe_property("video-dec-params", "native", function(name, params) Thumbnailer:on_video_change(params) end)


-- osc_tethys ExecutableFinder checks
ExecutableFinder.hasChecked = false
ExecutableFinder.hasFfmpeg = false
ExecutableFinder.hasMpv = false
ExecutableFinder.hasMpvNet = false
function ExecutableFinder:check()
    if ExecutableFinder.hasChecked then
        return
    end
    ExecutableFinder.hasFfmpeg = ExecutableFinder:get_executable_path("ffmpeg")
    ExecutableFinder.hasMpv = ExecutableFinder:get_executable_path("mpv")
    ExecutableFinder.hasMpvNet = ExecutableFinder:get_executable_path("mpvnet")
    ExecutableFinder.hasChecked = true
    -- msg.warn("hasFfmpeg", ExecutableFinder.hasFfmpeg)
    -- msg.warn("hasMpv", ExecutableFinder.hasMpv)
    -- msg.warn("hasMpvNet", ExecutableFinder.hasMpvNet)
end


-- osc_tethys mpv_thumbnail_script overrides
thumbnailer_options.thumbnail_width = tethys.thumbnailSize
thumbnailer_options.thumbnail_height = tethys.thumbnailSize
thumbnailer_options.mpv_no_config = true
thumbnailer_options.mpv_no_sub = true
thumbnailer_options.hide_progress = true -- Not implemented

Thumbnailer:register_client()


-- Thumbnail State
function ThumbState()
    return {
        overlayId = 1,
        visible = false,
        wasVisible = false,
        thumbPath = nil,
        globalWidth = nil,
        globalHeight = nil,
    }
end
local seekbarThumb = ThumbState()
seekbarThumb.overlayId = 1



















-- Render Funcs
function calcTrackButtonWidth(trackArr)
    -- "ICON -/0" or "ICON 1/1" or "ICON 1/10"
    local trackButtonSize = tethys.trackButtonSize
    local trackIconWidth = trackButtonSize * (32/23.273)
    local trackDigitWidth = trackButtonSize * (tethys.trackTextScale / 100) * 0.4
    local spaceDigitRatio = 0.4
    local slashDigitRatio = 0.7
    -- print("trackButtonSize", trackButtonSize)
    -- print("trackIconWidth", trackIconWidth)
    -- print("trackDigitWidth", trackDigitWidth)
    local numTrackDigits = 1
    if trackArr ~= nil and #trackArr > 0 then
        numTrackDigits = math.floor(math.log(#trackArr, 10)) + 1
    end
    local trackButtonWidth = math.ceil(trackIconWidth + trackDigitWidth * (spaceDigitRatio + numTrackDigits + slashDigitRatio + numTrackDigits))
    -- print("numTrackDigits", numTrackDigits)
    -- print("trackButtonWidth", trackButtonWidth)
    return trackButtonWidth
end

-- Thumbnail Funcs
function canShowThumb(videoPath)
    local isRemote = videoPath:find("://") ~= nil
    ExecutableFinder:check()
    if not (ExecutableFinder.hasMpv or ExecutableFinder.hasMpvNet or ExecutableFinder.hasFfmpeg) then
        return false
    end
    if isRemote then
        return false
    end
    return true
end

function showThumbnail(thumbState, globalX, globalY)
    -- https://mpv.io/manual/master/#command-interface-overlay-add
    -- msg.warn("showThumbnail", thumbState.overlayId)
    mp.command_native({
        "overlay-add", thumbState.overlayId,
        globalX, globalY,
        thumbState.thumbPath,
        0, -- byte offset
        "bgra", -- image format
        thumbState.globalWidth, thumbState.globalHeight,
        thumbState.globalWidth * 4, -- "stride"
    })
    thumbState.visible = true
end
function hideThumbnail(thumbState)
    -- https://mpv.io/manual/master/#command-interface-overlay-remove
    -- msg.warn("hideThumbnail", thumbState.overlayId)
    mp.command_native({
        "overlay-remove", thumbState.overlayId,
    })
end
function thumbPreRender(thumbState)
    thumbState.wasVisible = thumbState.visible
    thumbState.visible = false
end
function thumbPostRender(thumbState)
    if not thumbState.visible and thumbState.wasVisible then
        hideThumbnail(thumbState)
    end
end
function preRenderThumbnails()
    thumbPreRender(seekbarThumb)
end
function postRenderThumbnails()
    thumbPostRender(seekbarThumb)
end

-- From: Slider.tooltipF(pos)
function formatTimestamp(percent)
    local duration = mp.get_property_number("duration", nil)
    if not ((duration == nil) or (percent == nil)) then
        local sec = duration * (percent / 100)
        return mp.format_time(sec)
    else
        return ""
    end
end

-- Seekbar Tooltip
function renderThumbnailTooltip(pos, sliderPos, ass)
    local tooltipBgColor = "FFFFFF"
    local tooltipBgAlpha = 80
    local thumbOutline = 3

    local videoPath = mp.get_property_native("path", nil)
    local videoDuration = mp.get_property_number("duration", nil)
    -- msg.warn("sliderPos", sliderPos, "videoDuration", videoDuration, "videoPath", videoPath)
    if (videoPath == nil) or (videoDuration == nil) or (sliderPos == nil) then
        return
    end
    local thumbTime = videoDuration * (sliderPos / 100)
    local thumbTimestamp = mp.format_time(thumbTime) -- ffmpeg requires "HH:MM:SS.zzz" for seeking
    local timestampLabel = thumbTimestamp
    -- msg.warn("thumbTime", thumbTime, "timestampLabel", timestampLabel)

    ---- Geometry
    local scaleX, scaleY = get_virt_scale_factor()
    local videoDecParams = mp.get_property_native("video-dec-params")
    if videoDecParams == nil then
        return
    end
    local videoWidth = videoDecParams.dw
    local videoHeight = videoDecParams.dh
    if not (videoWidth and videoHeight) then
        return
    end

    local thumb_size = Thumbnailer.state.thumbnail_size
    if thumb_size == nil then
        return
    end
    local thumbGlobalWidth = thumb_size.w
    local thumbGlobalHeight = thumb_size.h
    local thumbWidth =  math.floor(thumbGlobalWidth * scaleX)
    local thumbHeight =  math.floor(thumbGlobalHeight * scaleY)

    local chapter = get_chapter(thumbTime)
    local hasChapter = not (chapter == nil) and chapter.title and chapter.title ~= ""
    local showChapter = hasChapter and tethys.showChapterTooltip
    local chapterLabel = ""
    local chapterHeight = 0
    if showChapter then
        chapterHeight = tethys.seekbarTimestampSize
        chapterLabel = chapter.title
    end

    local timestampWidth = thumbWidth
    local timestampHeight = tethys.seekbarTimestampSize

    local bgHeight = thumbOutline + thumbHeight + thumbOutline

    local tooltipWidth = thumbOutline + thumbWidth + thumbOutline
    local tooltipHeight = bgHeight + chapterHeight + timestampHeight


    -- Note: pos x,y is an=2 (bottom-center)
    local windowWidth = osc_param.playresx
    local tooltipX = math.floor(pos.x - tooltipWidth/2)
    local tooltipY = math.floor(pos.y - tooltipHeight)
    local textAn = 5 -- x,y is center
    local isLongChapter
    if tooltipX < 0 then
        tooltipX = 0
        textAn = 4 -- x,y is left-center
    elseif windowWidth - tooltipWidth < tooltipX then
        tooltipX = windowWidth - tooltipWidth
        textAn = 6 -- x,y is right-center
    end

    local thumbX = tooltipX + thumbOutline
    local thumbY = tooltipY + thumbOutline
    local thumbGlobalX = math.floor(thumbX / scaleX)
    local thumbGlobalY = math.floor(thumbY / scaleY)
    -- msg.warn("thumbX", thumbX, "thumbY", thumbY, "thumbGlobalX", thumbGlobalX, "thumbGlobalY", thumbGlobalY)


    local longChapterTitle = chapterLabel:len() >= 30
    local chapterAn = longChapterTitle and textAn or 5 -- x,y is center
    local chapterX
    if chapterAn == 4 then -- Left-Center
        chapterX = thumbX
    elseif chapterAn == 6 then -- Right-Center
        chapterX = thumbX + thumbWidth
    else -- Center
        chapterX = thumbX + math.floor(thumbWidth/2)
    end
    local chapterY = thumbY + thumbHeight + math.floor(chapterHeight/2)

    local timestampAn = 5 -- x,y is center
    local timestampX = thumbX + math.floor(thumbWidth/2)
    local timestampY = thumbY + thumbHeight + chapterHeight + math.floor(timestampHeight/2)

    ---- Chapter
    if showChapter then
        ass:new_event()
        ass:pos(chapterX, chapterY)
        ass:an(chapterAn)
        ass:append(tethysStyle.seekbarTimestamp)
        ass:append(chapterLabel)
    end

    ---- Timestamp
    ass:new_event()
    ass:pos(timestampX, timestampY)
    ass:an(timestampAn)
    ass:append(tethysStyle.seekbarTimestamp)
    ass:append(timestampLabel)

    -- If thumbnails are not available, bail
    if not (Thumbnailer.state.enabled and Thumbnailer.state.available) then
        return
    end

    local thumbPath, thumbIndex, closestIndex = Thumbnailer:get_thumbnail_path(thumbTime)
    -- msg.warn("renderThumbnailTooltip", thumbIndex, closestIndex, thumbPath)

    if thumbPath then
        ---- Thumb BG/Outline
        ass:new_event()
        ass:pos(tooltipX, tooltipY)
        ass:an(7)
        ass:append(("{\\bord0\\1c&H%s&\\1a&H%X&}"):format(tooltipBgColor, tooltipBgAlpha))
        ass:draw_start()
        ass:rect_cw(0, 0, tooltipWidth, bgHeight)
        ass:draw_stop()

        ---- Thumb BG
        if not (tooltipBgAlpha == 0) then
            -- Overlay Image must be drawn on top of a solid color or else it'll look
            -- like it was filtered.
            ass:new_event()
            ass:pos(thumbX, thumbY)
            ass:an(7)
            ass:append(("{\\bord0\\1c&H%s&\\1a&H%X&}"):format(tooltipBgColor, 0))
            ass:draw_start()
            ass:rect_cw(0, 0, thumbWidth, thumbHeight)
            ass:draw_stop()
        end

        ---- Render Thumbnail
        seekbarThumb.thumbPath = thumbPath
        seekbarThumb.globalWidth = thumbGlobalWidth
        seekbarThumb.globalHeight = thumbGlobalHeight
        showThumbnail(seekbarThumb, thumbGlobalX, thumbGlobalY)
    end
end

-- Playlist Tooltip
function renderPlaylistTooltip(pos, playlistDelta, ass)
    local deltaItem = getDeltaPlaylistItem(playlistDelta)
    if deltaItem == nil then
        return nil
    end

    local videoPath = deltaItem.filename
    local thumbTimestamp = mp.format_time(0.5)
    local thumbGlobalWidth = 100
    local thumbGlobalHeight = 100
end



















-- internal states, do not touch
local state = {
    showtime,                               -- time of last invocation (last mouse move)
    osc_visible = false,
    anistart,                               -- time when the animation started
    anitype,                                -- current type of animation
    animation,                              -- current animation alpha
    mouse_down_counter = 0,                 -- used for softrepeat
    active_element = nil,                   -- nil = none, 0 = background, 1+ = see elements[]
    active_event_source = nil,              -- the "button" that issued the current event
    rightTC_trem = not user_opts.timetotal, -- if the right timecode should display total or remaining time
    tc_ms = user_opts.timems,               -- Should the timecodes display their time with milliseconds
    mp_screen_sizeX, mp_screen_sizeY,       -- last screen-resolution, to detect resolution changes to issue reINITs
    initREQ = false,                        -- is a re-init request pending?
    marginsREQ = false,                     -- is a margins update pending?
    last_mouseX, last_mouseY,               -- last mouse position, to detect significant mouse movement
    mouse_in_window = false,
    message_text,
    message_hide_timer,
    fullscreen = false,
    tick_timer = nil,
    tick_last_time = 0,                     -- when the last tick() was run
    hide_timer = nil,
    cache_state = nil,
    idle = false,
    enabled = true,
    input_enabled = true,
    showhide_enabled = false,
    dmx_cache = 0,
    using_video_margins = false,
    border = true,
    maximized = false,
    osd = mp.create_osd_overlay("ass-events"),
    chapter_list = {},                      -- sorted by time
}

local window_control_box_width = 80
local tick_delay = 0.03

local is_december = os.date("*t").month == 12

--
-- Helperfunctions
--

function kill_animation()
    state.anistart = nil
    state.animation = nil
    state.anitype =  nil
end

function set_osd(res_x, res_y, text)
    if state.osd.res_x == res_x and
       state.osd.res_y == res_y and
       state.osd.data == text then
        return
    end
    state.osd.res_x = res_x
    state.osd.res_y = res_y
    state.osd.data = text
    state.osd.z = 1000
    state.osd:update()
end

local margins_opts = {
    {"l", "video-margin-ratio-left"},
    {"r", "video-margin-ratio-right"},
    {"t", "video-margin-ratio-top"},
    {"b", "video-margin-ratio-bottom"},
}

-- scale factor for translating between real and virtual ASS coordinates
function get_virt_scale_factor()
    local w, h = mp.get_osd_size()
    if w <= 0 or h <= 0 then
        return 0, 0
    end
    return osc_param.playresx / w, osc_param.playresy / h
end

-- return mouse position in virtual ASS coordinates (playresx/y)
function get_virt_mouse_pos()
    if state.mouse_in_window then
        local sx, sy = get_virt_scale_factor()
        local x, y = mp.get_mouse_pos()
        return x * sx, y * sy
    else
        return -1, -1
    end
end

function set_virt_mouse_area(x0, y0, x1, y1, name)
    local sx, sy = get_virt_scale_factor()
    mp.set_mouse_area(x0 / sx, y0 / sy, x1 / sx, y1 / sy, name)
end

function scale_value(x0, x1, y0, y1, val)
    local m = (y1 - y0) / (x1 - x0)
    local b = y0 - (m * x0)
    return (m * val) + b
end

-- returns hitbox spanning coordinates (top left, bottom right corner)
-- according to alignment
function get_hitbox_coords(x, y, an, w, h)

    local alignments = {
      [1] = function () return x, y-h, x+w, y end,
      [2] = function () return x-(w/2), y-h, x+(w/2), y end,
      [3] = function () return x-w, y-h, x, y end,

      [4] = function () return x, y-(h/2), x+w, y+(h/2) end,
      [5] = function () return x-(w/2), y-(h/2), x+(w/2), y+(h/2) end,
      [6] = function () return x-w, y-(h/2), x, y+(h/2) end,

      [7] = function () return x, y, x+w, y+h end,
      [8] = function () return x-(w/2), y, x+(w/2), y+h end,
      [9] = function () return x-w, y, x, y+h end,
    }

    return alignments[an]()
end

function get_hitbox_coords_geo(geometry)
    return get_hitbox_coords(geometry.x, geometry.y, geometry.an,
        geometry.w, geometry.h)
end

function get_element_hitbox(element)
    return element.hitbox.x1, element.hitbox.y1,
        element.hitbox.x2, element.hitbox.y2
end

function mouse_hit(element)
    return mouse_hit_coords(get_element_hitbox(element))
end

function mouse_hit_coords(bX1, bY1, bX2, bY2)
    local mX, mY = get_virt_mouse_pos()
    return (mX >= bX1 and mX <= bX2 and mY >= bY1 and mY <= bY2)
end

function limit_range(min, max, val)
    if val > max then
        val = max
    elseif val < min then
        val = min
    end
    return val
end

-- translate value into element coordinates
function get_slider_ele_pos_for(element, val)

    local ele_pos = scale_value(
        element.slider.min.value, element.slider.max.value,
        element.slider.min.ele_pos, element.slider.max.ele_pos,
        val)

    return limit_range(
        element.slider.min.ele_pos, element.slider.max.ele_pos,
        ele_pos)
end

-- translates global (mouse) coordinates to value
function get_slider_value_at(element, glob_pos)

    local val = scale_value(
        element.slider.min.glob_pos, element.slider.max.glob_pos,
        element.slider.min.value, element.slider.max.value,
        glob_pos)

    return limit_range(
        element.slider.min.value, element.slider.max.value,
        val)
end

-- get value at current mouse position
function get_slider_value(element)
    return get_slider_value_at(element, get_virt_mouse_pos())
end

function countone(val)
    if not (user_opts.iamaprogrammer) then
        val = val + 1
    end
    return val
end

-- align:  -1 .. +1
-- frame:  size of the containing area
-- obj:    size of the object that should be positioned inside the area
-- margin: min. distance from object to frame (as long as -1 <= align <= +1)
function get_align(align, frame, obj, margin)
    return (frame / 2) + (((frame / 2) - margin - (obj / 2)) * align)
end

-- multiplies two alpha values, formular can probably be improved
function mult_alpha(alphaA, alphaB)
    return 255 - (((1-(alphaA/255)) * (1-(alphaB/255))) * 255)
end

function add_area(name, x1, y1, x2, y2)
    -- create area if needed
    if (osc_param.areas[name] == nil) then
        osc_param.areas[name] = {}
    end
    table.insert(osc_param.areas[name], {x1=x1, y1=y1, x2=x2, y2=y2})
end

function ass_append_alpha(ass, alpha, modifier)
    local ar = {}

    for ai, av in pairs(alpha) do
        av = mult_alpha(av, modifier)
        if state.animation then
            av = mult_alpha(av, state.animation)
        end
        ar[ai] = av
    end

    ass:append(string.format("{\\1a&H%X&\\2a&H%X&\\3a&H%X&\\4a&H%X&}",
               ar[1], ar[2], ar[3], ar[4]))
end

function ass_draw_rr_h_cw(ass, x0, y0, x1, y1, r1, hexagon, r2)
    if hexagon then
        ass:hexagon_cw(x0, y0, x1, y1, r1, r2)
    else
        ass:round_rect_cw(x0, y0, x1, y1, r1, r2)
    end
end

function ass_draw_rr_h_ccw(ass, x0, y0, x1, y1, r1, hexagon, r2)
    if hexagon then
        ass:hexagon_ccw(x0, y0, x1, y1, r1, r2)
    else
        ass:round_rect_ccw(x0, y0, x1, y1, r1, r2)
    end
end


--
-- Picture In Picture
--

function togglePictureInPicture()
    local isPiP = tethys.isPictureInPicture
    if isPiP then -- Disable
        mp.commandv('set', 'on-all-workspaces', 'no')
        if not tethys.pipWasOnTop then
            mp.commandv('set', 'ontop', 'no')
        end
        if tethys.pipHadBorders then
            mp.commandv('set', 'border', 'yes')
        end
        local videoDecParams = mp.get_property_native("video-dec-params")
        if videoDecParams ~= nil then
            local videoWidth = videoDecParams.dw
            local videoHeight = videoDecParams.dh
            if videoWidth and videoHeight then
                mp.commandv('set', 'geometry', ''..videoWidth..'x'..videoHeight)
            end
        end
        if tethys.pipWasMaximized then
            mp.commandv('set', 'window-maximized', 'yes')
        end
        if tethys.pipWasFullscreen then
            mp.commandv('set', 'fullscreen', 'yes')
        end
    else -- Enable
        tethys.pipWasFullscreen = state.fullscreen
        tethys.pipWasMaximized = state.maximized
        tethys.pipWasOnTop = mp.get_property('ontop') == "yes"
        tethys.pipHadBorders = state.border
        mp.commandv('set', 'fullscreen', 'no')
        mp.commandv('set', 'window-maximized', 'no')
        mp.commandv('set', 'border', 'no')
        mp.commandv('set', 'geometry', tethys.pipGeometry)
        mp.commandv('set', 'ontop', 'yes')
        if tethys.pipAllWorkspaces then
            mp.commandv('set', 'on-all-workspaces', 'yes')
        end
    end
    tethys.isPictureInPicture = not isPiP
    utils.shared_script_property_set("pictureinpicture", tostring(tethys.isPictureInPicture))
end


--
-- Tracklist Management
--

local nicetypes = {video = "Video", audio = "Audio", sub = "Subtitle"}

-- updates the OSC internal playlists, should be run each time the track-layout changes
function update_tracklist()
    local tracktable = mp.get_property_native("track-list", {})

    -- by osc_id
    tracks_osc = {}
    tracks_osc.video, tracks_osc.audio, tracks_osc.sub = {}, {}, {}
    -- by mpv_id
    tracks_mpv = {}
    tracks_mpv.video, tracks_mpv.audio, tracks_mpv.sub = {}, {}, {}
    for n = 1, #tracktable do
        if not (tracktable[n].type == "unknown") then
            local type = tracktable[n].type
            local mpv_id = tonumber(tracktable[n].id)

            -- by osc_id
            table.insert(tracks_osc[type], tracktable[n])

            -- by mpv_id
            tracks_mpv[type][mpv_id] = tracktable[n]
            tracks_mpv[type][mpv_id].osc_id = #tracks_osc[type]
        end
    end
end

-- return a nice list of tracks of the given type (video, audio, sub)
function get_tracklist(type)
    local msg = "Available " .. nicetypes[type] .. " Tracks: "
    if not tracks_osc or #tracks_osc[type] == 0 then
        msg = msg .. "none"
    else
        for n = 1, #tracks_osc[type] do
            local track = tracks_osc[type][n]
            local lang, title, selected = "unknown", "", "○"
            if not(track.lang == nil) then lang = track.lang end
            if not(track.title == nil) then title = track.title end
            if (track.id == tonumber(mp.get_property(type))) then
                selected = "●"
            end
            msg = msg.."\n"..selected.." "..n..": ["..lang.."] "..title
        end
    end
    return msg
end

-- relatively change the track of given <type> by <next> tracks
    --(+1 -> next, -1 -> previous)
function set_track(type, next)
    local current_track_mpv, current_track_osc
    if (mp.get_property(type) == "no") then
        current_track_osc = 0
    else
        current_track_mpv = tonumber(mp.get_property(type))
        current_track_osc = tracks_mpv[type][current_track_mpv].osc_id
    end
    local new_track_osc = (current_track_osc + next) % (#tracks_osc[type] + 1)
    local new_track_mpv
    if new_track_osc == 0 then
        new_track_mpv = "no"
    else
        new_track_mpv = tracks_osc[type][new_track_osc].id
    end

    mp.commandv("set", type, new_track_mpv)

        if (new_track_osc == 0) then
        show_message(nicetypes[type] .. " Track: none")
    else
        show_message(nicetypes[type]  .. " Track: "
            .. new_track_osc .. "/" .. #tracks_osc[type]
            .. " [".. (tracks_osc[type][new_track_osc].lang or "unknown") .."] "
            .. (tracks_osc[type][new_track_osc].title or ""))
    end
end

-- get the currently selected track of <type>, OSC-style counted
function get_track(type)
    local track = mp.get_property(type)
    if track ~= "no" and track ~= nil then
        local tr = tracks_mpv[type][tonumber(track)]
        if tr then
            return tr.osc_id
        end
    end
    return 0
end

-- WindowControl helpers
function window_controls_enabled()
    val = user_opts.windowcontrols
    if val == "auto" then
        return not state.border
    else
        return val ~= "no"
    end
end

function window_controls_alignment()
    return user_opts.windowcontrols_alignment
end

--
-- Element Management
--

local elements = {}

function new_ass_node(elem_ass)
    elem_ass:append("{}") -- hack to troll new_event into inserting a \n
    elem_ass:new_event()
end
function reset_ass(elem_ass, element)
    new_ass_node(elem_ass)
    local elem_geo = element.layout.geometry
    elem_ass:pos(elem_geo.x, elem_geo.y)
    elem_ass:an(elem_geo.an)
    elem_ass:append(element.layout.style)
end

function prepare_elements()

    -- remove elements without layout or invisble
    local elements2 = {}
    for n, element in pairs(elements) do
        if not (element.layout == nil) and (element.visible) then
            table.insert(elements2, element)
        end
    end
    elements = elements2

    function elem_compare (a, b)
        return a.layout.layer < b.layout.layer
    end

    table.sort(elements, elem_compare)


    for _,element in pairs(elements) do

        local elem_geo = element.layout.geometry

        -- Calculate the hitbox
        local bX1, bY1, bX2, bY2 = get_hitbox_coords_geo(elem_geo)
        element.hitbox = {x1 = bX1, y1 = bY1, x2 = bX2, y2 = bY2}

        local style_ass = assdraw.ass_new()

        -- prepare static elements
        reset_ass(style_ass, element)
        -- style_ass:append("{}") -- hack to troll new_event into inserting a \n
        -- style_ass:new_event()
        -- style_ass:pos(elem_geo.x, elem_geo.y)
        -- style_ass:an(elem_geo.an)
        -- style_ass:append(element.layout.style)

        element.style_ass = style_ass

        local static_ass = assdraw.ass_new()


        if (element.type == "box") then
            --draw box
            static_ass:draw_start()
            ass_draw_rr_h_cw(static_ass, 0, 0, elem_geo.w, elem_geo.h,
                             element.layout.box.radius, element.layout.box.hexagon)
            static_ass:draw_stop()

        elseif (element.type == "slider") then
            --draw static slider parts

            local r1 = 0
            local r2 = 0
            local slider_lo = element.layout.slider
            -- offset between element outline and drag-area
            local foV = slider_lo.border + slider_lo.gap

            -- calculate positions of min and max points
            if (slider_lo.stype ~= "bar") then
                r1 = elem_geo.h / 2
                element.slider.min.ele_pos = elem_geo.h / 2
                element.slider.max.ele_pos = elem_geo.w - (elem_geo.h / 2)
                if (slider_lo.stype == "diamond") then
                    r2 = (elem_geo.h - 2 * slider_lo.border) / 2
                elseif (slider_lo.stype == "knob") then
                    r2 = r1
                end
            else
                element.sli